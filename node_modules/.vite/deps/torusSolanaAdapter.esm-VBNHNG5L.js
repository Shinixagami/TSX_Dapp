import {
  require_fast_deep_equal,
  require_is_stream
} from "./chunk-BJMXI6MQ.js";
import {
  PublicKey,
  TorusInjectedProvider,
  init_index_browser_esm,
  init_solanaProvider_esm
} from "./chunk-YWL2POHT.js";
import "./chunk-44TGOI7W.js";
import {
  COMMUNICATION_JRPC_METHODS,
  COMMUNICATION_NOTIFICATIONS,
  PROVIDER_JRPC_METHODS,
  PROVIDER_NOTIFICATIONS,
  createLoggerMiddleware,
  init_baseControllers_esm
} from "./chunk-JMSNP5OZ.js";
import "./chunk-WYOYCXAS.js";
import "./chunk-VG2MP6HV.js";
import "./chunk-N4XIP4TA.js";
import {
  init_httpHelpers_esm,
  setAPIKey
} from "./chunk-WV6JY4FM.js";
import "./chunk-HJ4FI4XZ.js";
import {
  require_loglevel
} from "./chunk-LZLTGSPD.js";
import "./chunk-MDAVZMLP.js";
import {
  ADAPTER_CATEGORY,
  ADAPTER_EVENTS,
  ADAPTER_NAMESPACES,
  ADAPTER_STATUS,
  BaseAdapter,
  BasePostMessageStream,
  CHAIN_NAMESPACES,
  JRPCEngine,
  ObjectMultiplex,
  SafeEventEmitter,
  WALLET_ADAPTERS,
  WalletInitializationError,
  WalletLoginError,
  _defineProperty,
  createIdRemapMiddleware,
  createStreamMiddleware,
  getChainConfig,
  getRpcPromiseCallback,
  init_base_esm,
  init_defineProperty,
  init_openloginJrpc_esm,
  require_fast_safe_stringify,
  require_pump
} from "./chunk-7JKCMCQN.js";
import {
  __commonJS,
  __esm,
  __toESM
} from "./chunk-JGDUASYK.js";

// node_modules/@toruslabs/solana-embed/node_modules/eth-rpc-errors/dist/classes.js
var require_classes = __commonJS({
  "node_modules/@toruslabs/solana-embed/node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError2 = class extends Error {
      constructor(code, message, data) {
        if (!Number.isInteger(code)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code;
        if (data !== void 0) {
          this.data = data;
        }
      }
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError2;
    var EthereumProviderError = class extends EthereumRpcError2 {
      constructor(code, message, data) {
        if (!isValidEthProviderCode(code)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code, message, data);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code) {
      return Number.isInteger(code) && code >= 1e3 && code <= 4999;
    }
    function stringifyReplacer(_, value) {
      if (value === "[Circular]") {
        return void 0;
      }
      return value;
    }
  }
});

// node_modules/@toruslabs/solana-embed/node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants = __commonJS({
  "node_modules/@toruslabs/solana-embed/node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/@toruslabs/solana-embed/node_modules/eth-rpc-errors/dist/utils.js
var require_utils = __commonJS({
  "node_modules/@toruslabs/solana-embed/node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants();
    var classes_1 = require_classes();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code)) {
        const codeString = code.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code) {
      if (!Number.isInteger(code)) {
        return false;
      }
      const codeString = code.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
      }
      const serialized = {};
      if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error) };
      }
      const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError;
    function isJsonRpcServerError(code) {
      return code >= -32099 && code <= -32e3;
    }
    function assignOriginalError(error) {
      if (error && typeof error === "object" && !Array.isArray(error)) {
        return Object.assign({}, error);
      }
      return error;
    }
    function hasKey(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/@toruslabs/solana-embed/node_modules/eth-rpc-errors/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@toruslabs/solana-embed/node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes();
    var utils_1 = require_utils();
    var error_constants_1 = require_error_constants();
    exports.ethErrors = {
      rpc: {
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code } = opts;
          if (!Number.isInteger(code) || code > -32005 || code < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code, opts);
        },
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code, message, data } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code, message, data);
        }
      }
    };
    function getEthJsonRpcError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function getEthProviderError(code, arg) {
      const [message, data] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data];
        }
      }
      return [];
    }
  }
});

// node_modules/@toruslabs/solana-embed/node_modules/eth-rpc-errors/dist/index.js
var require_dist = __commonJS({
  "node_modules/@toruslabs/solana-embed/node_modules/eth-rpc-errors/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_1 = require_utils();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_1.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_1.getMessageFromCode;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js
function createErrorMiddleware() {
  return (req, res, next) => {
    if (typeof req.method !== "string" || !req.method) {
      res.error = import_eth_rpc_errors.ethErrors.rpc.invalidRequest({
        message: "The request 'method' must be a non-empty string.",
        data: req
      });
    }
    next((done) => {
      const {
        error
      } = res;
      if (!error) {
        return done();
      }
      log.error("Torus - RPC Error: ".concat(error.message), error);
      return done();
    });
  };
}
function logStreamDisconnectWarning(remoteLabel, error, emitter) {
  let warningMsg = 'Torus: Lost connection to "'.concat(remoteLabel, '".');
  if (error !== null && error !== void 0 && error.stack) {
    warningMsg += "\n".concat(error.stack);
  }
  log.warn(warningMsg);
  if (emitter && emitter.listenerCount("error") > 0) {
    emitter.emit("error", warningMsg);
  }
}
function storageAvailable(type) {
  let storage;
  try {
    storage = window[type];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (e) {
    return e && (e.code === 22 || e.code === 1014 || e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") && storage && storage.length !== 0;
  }
}
function getPopupFeatures(_ref) {
  let {
    width: w,
    height: h
  } = _ref;
  const dualScreenLeft = window.screenLeft !== void 0 ? window.screenLeft : window.screenX;
  const dualScreenTop = window.screenTop !== void 0 ? window.screenTop : window.screenY;
  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
  const systemZoom = 1;
  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);
  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);
  const features = "titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=".concat(h / systemZoom, ",width=").concat(w / systemZoom, ",top=").concat(top, ",left=").concat(left);
  return features;
}
async function documentReady() {
  return new Promise((resolve) => {
    if (document.readyState !== "loading") {
      resolve();
    } else {
      handleEvent(document, "DOMContentLoaded", resolve);
    }
  });
}
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function imgExists(url) {
  return new Promise((resolve, reject) => {
    try {
      const img = document.createElement("img");
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
      img.src = url;
    } catch (e) {
      reject(e);
    }
  });
}
async function getSiteIcon(window2) {
  try {
    const {
      document: document2
    } = window2;
    let icon = document2.querySelector('head > link[rel="shortcut icon"]');
    if (icon && await imgExists(icon.href)) {
      return icon.href;
    }
    icon = Array.from(document2.querySelectorAll('head > link[rel="icon"]')).find((_icon) => Boolean(_icon.href));
    if (icon && await imgExists(icon.href)) {
      return icon.href;
    }
    return "";
  } catch (error) {
    return "";
  }
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var import_eth_rpc_errors, import_is_stream, import_pump, import_loglevel, import_fast_deep_equal, messages, TORUS_BUILD_ENV, BUTTON_POSITION, LOGIN_PROVIDER, translations, configuration, log, getWindowId, getTorusUrl, getUserLanguage, FEATURES_PROVIDER_CHANGE_WINDOW, FEATURES_DEFAULT_WALLET_WINDOW, FEATURES_DEFAULT_POPUP_WINDOW, FEATURES_CONFIRM_WINDOW, BaseProvider, handleEvent, htmlToElement, PopupHandler, TorusCommunicationProvider, TorusInPageProvider, getSiteName, getSiteMetadata, PROVIDER_UNSAFE_METHODS, COMMUNICATION_UNSAFE_METHODS, isLocalStorageAvailable, Torus;
var init_solanaEmbed_esm = __esm({
  "node_modules/@toruslabs/solana-embed/dist/solanaEmbed.esm.js"() {
    init_defineProperty();
    init_index_browser_esm();
    init_baseControllers_esm();
    init_httpHelpers_esm();
    init_openloginJrpc_esm();
    import_eth_rpc_errors = __toESM(require_dist());
    import_is_stream = __toESM(require_is_stream());
    import_pump = __toESM(require_pump());
    import_loglevel = __toESM(require_loglevel());
    import_fast_deep_equal = __toESM(require_fast_deep_equal());
    messages = {
      errors: {
        disconnected: () => "Torus: Lost connection to Torus.",
        permanentlyDisconnected: () => "Torus: Disconnected from iframe. Page reload required.",
        unsupportedSync: (method) => "Torus: The Torus Ethereum provider does not support synchronous methods like ".concat(method, " without a callback parameter."),
        invalidDuplexStream: () => "Must provide a Node.js-style duplex stream.",
        invalidOptions: (maxEventListeners) => "Invalid options. Received: { maxEventListeners: ".concat(maxEventListeners, "}"),
        invalidRequestArgs: () => "Expected a single, non-array, object argument.",
        invalidRequestMethod: () => "'args.method' must be a non-empty string.",
        invalidRequestParams: () => "'args.params' must be an object or array if provided.",
        invalidLoggerObject: () => "'args.logger' must be an object if provided.",
        invalidLoggerMethod: (method) => "'args.logger' must include required method '".concat(method, "'.")
      },
      info: {
        connected: (chainId) => 'Torus: Connected to chain with ID "'.concat(chainId, '".')
      },
      warnings: {}
    };
    TORUS_BUILD_ENV = {
      PRODUCTION: "production",
      DEVELOPMENT: "development",
      TESTING: "testing"
    };
    BUTTON_POSITION = {
      BOTTOM_LEFT: "bottom-left",
      TOP_LEFT: "top-left",
      BOTTOM_RIGHT: "bottom-right",
      TOP_RIGHT: "top-right"
    };
    LOGIN_PROVIDER = {
      GOOGLE: "google",
      FACEBOOK: "facebook",
      REDDIT: "reddit",
      DISCORD: "discord",
      TWITCH: "twitch",
      APPLE: "apple",
      LINE: "line",
      GITHUB: "github",
      KAKAO: "kakao",
      LINKEDIN: "linkedin",
      TWITTER: "twitter",
      WEIBO: "weibo",
      WECHAT: "wechat",
      EMAIL_PASSWORDLESS: "email_passwordless"
    };
    translations = {
      en: {
        embed: {
          continue: "Continue",
          actionRequired: "Authorization required",
          pendingAction: "Click continue to proceed with your request in a popup",
          cookiesRequired: "Cookies Required",
          enableCookies: "Please enable cookies in your browser preferences to access Torus",
          clickHere: "More Info"
        }
      },
      de: {
        embed: {
          continue: "Fortsetzen",
          actionRequired: "Autorisierung erforderlich",
          pendingAction: "Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren",
          cookiesRequired: "Cookies ben\xF6tigt",
          enableCookies: "Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen",
          clickHere: "Mehr Info"
        }
      },
      ja: {
        embed: {
          continue: "\u7D99\u7D9A\u3059\u308B",
          actionRequired: "\u8A8D\u8A3C\u304C\u5FC5\u8981\u3067\u3059",
          pendingAction: "\u7D9A\u884C\u3092\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u3001\u30DD\u30C3\u30D7\u30A2\u30C3\u30D7\u3067\u30EA\u30AF\u30A8\u30B9\u30C8\u3092\u7D9A\u884C\u3057\u307E\u3059",
          cookiesRequired: "\u5FC5\u8981\u306A\u30AF\u30C3\u30AD\u30FC",
          enableCookies: "Torus\u306B\u30A2\u30AF\u30BB\u30B9\u3059\u308B\u306B\u306F\u3001\u30D6\u30E9\u30A6\u30B6\u306E\u8A2D\u5B9A\u3067Cookie\u3092\u6709\u52B9\u306B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
          clickHere: "\u8A73\u3057\u304F\u306F"
        }
      },
      ko: {
        embed: {
          continue: "\uACC4\uC18D\uD558\uB2E4",
          actionRequired: "\uC2B9\uC778 \uD544\uC694",
          pendingAction: "\uD31D\uC5C5\uC5D0\uC11C \uC694\uCCAD\uC744 \uC9C4\uD589\uD558\uB824\uBA74 \uACC4\uC18D\uC744 \uD074\uB9AD\uD558\uC2ED\uC2DC\uC624.",
          cookiesRequired: "\uCFE0\uD0A4 \uD544\uC694",
          enableCookies: "\uBE0C\uB77C\uC6B0\uC800 \uD658\uACBD \uC124\uC815\uC5D0\uC11C \uCFE0\uD0A4\uB97C \uD65C\uC131\uD654\uD558\uC5EC Torus\uC5D0 \uC561\uC138\uC2A4\uD558\uC2ED\uC2DC\uC624.",
          clickHere: "\uB354 \uB9CE\uC740 \uC815\uBCF4"
        }
      },
      zh: {
        embed: {
          continue: "\u7EE7\u7EED",
          actionRequired: "\u9700\u8981\u6388\u6743",
          pendingAction: "\u5355\u51FB\u7EE7\u7EED\u4EE5\u5728\u5F39\u51FA\u7A97\u53E3\u4E2D\u7EE7\u7EED\u60A8\u7684\u8BF7\u6C42",
          cookiesRequired: "\u5FC5\u586BCookie",
          enableCookies: "\u8BF7\u5728\u60A8\u7684\u6D4F\u89C8\u5668\u9996\u9009\u9879\u4E2D\u542F\u7528cookie\u4EE5\u8BBF\u95EETorus\u3002",
          clickHere: "\u66F4\u591A\u4FE1\u606F"
        }
      }
    };
    configuration = {
      supportedVerifierList: [LOGIN_PROVIDER.GOOGLE, LOGIN_PROVIDER.REDDIT, LOGIN_PROVIDER.DISCORD],
      api: "https://api.tor.us",
      translations,
      prodTorusUrl: "",
      localStorageKey: "torus-".concat(window.location.hostname)
    };
    log = import_loglevel.default.getLogger("solana-embed");
    getWindowId = () => Math.random().toString(36).slice(2);
    getTorusUrl = async (buildEnv) => {
      let torusUrl;
      let logLevel;
      switch (buildEnv) {
        case "testing":
          torusUrl = "https://solana-testing.tor.us";
          logLevel = "debug";
          break;
        case "development":
          torusUrl = "http://localhost:8080";
          logLevel = "debug";
          break;
        default:
          torusUrl = "https://solana.tor.us";
          logLevel = "error";
          break;
      }
      return {
        torusUrl,
        logLevel
      };
    };
    getUserLanguage = () => {
      let userLanguage = window.navigator.language || "en-US";
      const userLanguages = userLanguage.split("-");
      userLanguage = Object.prototype.hasOwnProperty.call(configuration.translations, userLanguages[0]) ? userLanguages[0] : "en";
      return userLanguage;
    };
    FEATURES_PROVIDER_CHANGE_WINDOW = {
      height: 660,
      width: 375
    };
    FEATURES_DEFAULT_WALLET_WINDOW = {
      height: 740,
      width: 1315
    };
    FEATURES_DEFAULT_POPUP_WINDOW = {
      height: 700,
      width: 1200
    };
    FEATURES_CONFIRM_WINDOW = {
      height: 600,
      width: 400
    };
    BaseProvider = class extends SafeEventEmitter {
      constructor(connectionStream, _ref) {
        let {
          maxEventListeners = 100,
          jsonRpcStreamName = "provider"
        } = _ref;
        super();
        _defineProperty(this, "isTorus", void 0);
        _defineProperty(this, "_rpcEngine", void 0);
        _defineProperty(this, "jsonRpcConnectionEvents", void 0);
        _defineProperty(this, "_state", void 0);
        if (!(0, import_is_stream.duplex)(connectionStream)) {
          throw new Error(messages.errors.invalidDuplexStream());
        }
        this.isTorus = true;
        this.setMaxListeners(maxEventListeners);
        this._handleConnect = this._handleConnect.bind(this);
        this._handleDisconnect = this._handleDisconnect.bind(this);
        this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);
        this._rpcRequest = this._rpcRequest.bind(this);
        this._initializeState = this._initializeState.bind(this);
        this.request = this.request.bind(this);
        this.sendAsync = this.sendAsync.bind(this);
        const mux = new ObjectMultiplex();
        (0, import_pump.default)(connectionStream, mux, connectionStream, this._handleStreamDisconnect.bind(this, "Torus"));
        mux.ignoreStream("phishing");
        const jsonRpcConnection = createStreamMiddleware();
        (0, import_pump.default)(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, "Torus RpcProvider"));
        const rpcEngine = new JRPCEngine();
        rpcEngine.push(createIdRemapMiddleware());
        rpcEngine.push(createErrorMiddleware());
        rpcEngine.push(createLoggerMiddleware({
          origin: location.origin
        }));
        rpcEngine.push(jsonRpcConnection.middleware);
        this._rpcEngine = rpcEngine;
        this.jsonRpcConnectionEvents = jsonRpcConnection.events;
      }
      async request(args) {
        if (!args || typeof args !== "object" || Array.isArray(args)) {
          throw import_eth_rpc_errors.ethErrors.rpc.invalidRequest({
            message: messages.errors.invalidRequestArgs(),
            data: args
          });
        }
        const {
          method,
          params
        } = args;
        if (typeof method !== "string" || method.length === 0) {
          throw import_eth_rpc_errors.ethErrors.rpc.invalidRequest({
            message: messages.errors.invalidRequestMethod(),
            data: args
          });
        }
        if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
          throw import_eth_rpc_errors.ethErrors.rpc.invalidRequest({
            message: messages.errors.invalidRequestParams(),
            data: args
          });
        }
        return new Promise((resolve, reject) => {
          this._rpcRequest({
            method,
            params
          }, getRpcPromiseCallback(resolve, reject));
        });
      }
      send(payload, callback) {
        this._rpcRequest(payload, callback);
      }
      sendAsync(payload) {
        return new Promise((resolve, reject) => {
          this._rpcRequest(payload, getRpcPromiseCallback(resolve, reject));
        });
      }
      _handleStreamDisconnect(streamName, error) {
        logStreamDisconnectWarning(streamName, error, this);
        this._handleDisconnect(false, error ? error.message : void 0);
      }
    };
    handleEvent = function(handle, eventName, handler) {
      for (var _len = arguments.length, handlerArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
        handlerArgs[_key - 3] = arguments[_key];
      }
      const handlerWrapper = () => {
        handler(...handlerArgs);
        handle.removeEventListener(eventName, handlerWrapper);
      };
      handle.addEventListener(eventName, handlerWrapper);
    };
    htmlToElement = (html) => {
      const template = window.document.createElement("template");
      const trimmedHtml = html.trim();
      template.innerHTML = trimmedHtml;
      return template.content.firstChild;
    };
    PopupHandler = class extends SafeEventEmitter {
      constructor(_ref) {
        let {
          url,
          target,
          features
        } = _ref;
        super();
        _defineProperty(this, "url", void 0);
        _defineProperty(this, "target", void 0);
        _defineProperty(this, "features", void 0);
        _defineProperty(this, "window", void 0);
        _defineProperty(this, "windowTimer", void 0);
        _defineProperty(this, "iClosedWindow", void 0);
        this.url = url;
        this.target = target || "_blank";
        this.features = features || getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW);
        this.window = void 0;
        this.windowTimer = void 0;
        this.iClosedWindow = false;
        this._setupTimer();
      }
      _setupTimer() {
        this.windowTimer = Number(setInterval(() => {
          if (this.window && this.window.closed) {
            clearInterval(this.windowTimer);
            if (!this.iClosedWindow) {
              this.emit("close");
            }
            this.iClosedWindow = false;
            this.window = void 0;
          }
          if (this.window === void 0)
            clearInterval(this.windowTimer);
        }, 500));
      }
      open() {
        var _this$window;
        this.window = window.open(this.url.href, this.target, this.features);
        if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus)
          this.window.focus();
        return Promise.resolve();
      }
      close() {
        this.iClosedWindow = true;
        if (this.window)
          this.window.close();
      }
      redirect(locationReplaceOnRedirect) {
        if (locationReplaceOnRedirect) {
          window.location.replace(this.url.href);
        } else {
          window.location.href = this.url.href;
        }
      }
    };
    TorusCommunicationProvider = class extends BaseProvider {
      constructor(connectionStream, _ref) {
        let {
          maxEventListeners = 100,
          jsonRpcStreamName = "provider"
        } = _ref;
        super(connectionStream, {
          maxEventListeners,
          jsonRpcStreamName
        });
        _defineProperty(this, "embedTranslations", void 0);
        _defineProperty(this, "torusUrl", void 0);
        _defineProperty(this, "dappStorageKey", void 0);
        _defineProperty(this, "windowRefs", void 0);
        _defineProperty(this, "tryWindowHandle", void 0);
        _defineProperty(this, "torusAlertContainer", void 0);
        _defineProperty(this, "torusIframe", void 0);
        this._state = _objectSpread$2({}, TorusCommunicationProvider._defaultState);
        this.torusUrl = "";
        this.dappStorageKey = "";
        const languageTranslations = configuration.translations[getUserLanguage()];
        this.embedTranslations = languageTranslations.embed;
        this.windowRefs = {};
        this.on("connect", () => {
          this._state.isConnected = true;
        });
        const notificationHandler = (payload) => {
          const {
            method,
            params
          } = payload;
          if (method === COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {
            const {
              isFullScreen,
              rid
            } = params;
            this._displayIframe({
              isFull: isFullScreen,
              rid
            });
          } else if (method === COMMUNICATION_NOTIFICATIONS.CREATE_WINDOW) {
            const {
              windowId,
              url
            } = params;
            this._createPopupBlockAlert(windowId, url);
          } else if (method === COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) {
            this._handleCloseWindow(params);
          } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {
            const {
              currentLoginProvider
            } = params;
            this._state.isLoggedIn = true;
            this._state.currentLoginProvider = currentLoginProvider;
          } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {
            this._state.isLoggedIn = false;
            this._state.currentLoginProvider = null;
            this._displayIframe();
          }
        };
        this.jsonRpcConnectionEvents.on("notification", notificationHandler);
      }
      get isLoggedIn() {
        return this._state.isLoggedIn;
      }
      get isIFrameFullScreen() {
        return this._state.isIFrameFullScreen;
      }
      isConnected() {
        return this._state.isConnected;
      }
      async _initializeState(params) {
        try {
          const {
            torusUrl,
            dappStorageKey,
            torusAlertContainer,
            torusIframe
          } = params;
          this.torusUrl = torusUrl;
          this.dappStorageKey = dappStorageKey;
          this.torusAlertContainer = torusAlertContainer;
          this.torusIframe = torusIframe;
          this.torusIframe.addEventListener("load", () => {
            if (!this._state.isIFrameFullScreen)
              this._displayIframe();
          });
          const {
            currentLoginProvider,
            isLoggedIn
          } = await this.request({
            method: COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,
            params: []
          });
          this._handleConnect(currentLoginProvider, isLoggedIn);
        } catch (error) {
          log.error("Torus: Failed to get initial state. Please report this bug.", error);
        } finally {
          log.info("initialized communication state");
          this._state.initialized = true;
          this.emit("_initialized");
        }
      }
      _handleWindow(windowId) {
        let {
          url,
          target,
          features
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const finalUrl = new URL(url || "".concat(this.torusUrl, "/redirect?windowId=").concat(windowId));
        if (this.dappStorageKey) {
          if (finalUrl.hash)
            finalUrl.hash += "&dappStorageKey=".concat(this.dappStorageKey);
          else
            finalUrl.hash = "#dappStorageKey=".concat(this.dappStorageKey);
        }
        const handledWindow = new PopupHandler({
          url: finalUrl,
          target,
          features
        });
        handledWindow.open();
        if (!handledWindow.window) {
          this._createPopupBlockAlert(windowId, finalUrl.href);
          return;
        }
        this.windowRefs[windowId] = handledWindow;
        this.request({
          method: COMMUNICATION_JRPC_METHODS.OPENED_WINDOW,
          params: {
            windowId
          }
        });
        handledWindow.once("close", () => {
          delete this.windowRefs[windowId];
          this.request({
            method: COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,
            params: {
              windowId
            }
          });
        });
      }
      _displayIframe() {
        let {
          isFull = false,
          rid = ""
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const style = {};
        if (!isFull) {
          style.display = this._state.torusWidgetVisibility ? "block" : "none";
          style.height = "70px";
          style.width = "70px";
          switch (this._state.buttonPosition) {
            case BUTTON_POSITION.TOP_LEFT:
              style.top = "0px";
              style.left = "0px";
              style.right = "auto";
              style.bottom = "auto";
              break;
            case BUTTON_POSITION.TOP_RIGHT:
              style.top = "0px";
              style.right = "0px";
              style.left = "auto";
              style.bottom = "auto";
              break;
            case BUTTON_POSITION.BOTTOM_RIGHT:
              style.bottom = "0px";
              style.right = "0px";
              style.top = "auto";
              style.left = "auto";
              break;
            case BUTTON_POSITION.BOTTOM_LEFT:
            default:
              style.bottom = "0px";
              style.left = "0px";
              style.top = "auto";
              style.right = "auto";
              break;
          }
        } else {
          style.display = "block";
          style.width = "100%";
          style.height = "100%";
          style.top = "0px";
          style.right = "0px";
          style.left = "0px";
          style.bottom = "0px";
        }
        Object.assign(this.torusIframe.style, style);
        this._state.isIFrameFullScreen = isFull;
        this.request({
          method: COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,
          params: {
            isIFrameFullScreen: isFull,
            rid
          }
        });
      }
      hideTorusButton() {
        this._state.torusWidgetVisibility = false;
        this._displayIframe();
      }
      showTorusButton() {
        this._state.torusWidgetVisibility = true;
        this._displayIframe();
      }
      _rpcRequest(payload, callback) {
        const cb = callback;
        const _payload = payload;
        if (!Array.isArray(_payload)) {
          if (!_payload.jsonrpc) {
            _payload.jsonrpc = "2.0";
          }
        }
        this.tryWindowHandle(_payload, cb);
      }
      _handleConnect(currentLoginProvider, isLoggedIn) {
        if (!this._state.isConnected) {
          this._state.isConnected = true;
          this.emit("connect", {
            currentLoginProvider,
            isLoggedIn
          });
          log.debug(messages.info.connected(currentLoginProvider));
        }
      }
      _handleDisconnect(isRecoverable, errorMessage) {
        if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {
          this._state.isConnected = false;
          let error;
          if (isRecoverable) {
            error = new import_eth_rpc_errors.EthereumRpcError(1013, errorMessage || messages.errors.disconnected());
            log.debug(error);
          } else {
            error = new import_eth_rpc_errors.EthereumRpcError(1011, errorMessage || messages.errors.permanentlyDisconnected());
            log.error(error);
            this._state.currentLoginProvider = null;
            this._state.isLoggedIn = false;
            this._state.torusWidgetVisibility = false;
            this._state.isIFrameFullScreen = false;
            this._state.isPermanentlyDisconnected = true;
          }
          this.emit("disconnect", error);
        }
      }
      _handleCloseWindow(params) {
        const {
          windowId
        } = params;
        if (this.windowRefs[windowId]) {
          this.windowRefs[windowId].close();
          delete this.windowRefs[windowId];
        }
      }
      async _createPopupBlockAlert(windowId, url) {
        const logoUrl = this.getLogoUrl();
        const torusAlert = htmlToElement('<div id="torusAlert" class="torus-alert--v2">' + '<div id="torusAlert__logo"><img src="'.concat(logoUrl, '" /></div>') + "<div>" + '<h1 id="torusAlert__title">'.concat(this.embedTranslations.actionRequired, "</h1>") + '<p id="torusAlert__desc">'.concat(this.embedTranslations.pendingAction, "</p>") + "</div></div>");
        const successAlert = htmlToElement('<div><a id="torusAlert__btn">'.concat(this.embedTranslations.continue, "</a></div>"));
        const btnContainer = htmlToElement('<div id="torusAlert__btn-container"></div>');
        btnContainer.appendChild(successAlert);
        torusAlert.appendChild(btnContainer);
        const bindOnLoad = () => {
          successAlert.addEventListener("click", () => {
            this._handleWindow(windowId, {
              url,
              target: "_blank",
              features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)
            });
            torusAlert.remove();
            if (this.torusAlertContainer.children.length === 0)
              this.torusAlertContainer.style.display = "none";
          });
        };
        const attachOnLoad = () => {
          this.torusAlertContainer.appendChild(torusAlert);
        };
        await documentReady();
        attachOnLoad();
        bindOnLoad();
        this.torusAlertContainer.style.display = "block";
      }
      getLogoUrl() {
        const logoUrl = "".concat(this.torusUrl, "/images/torus_icon-blue.svg");
        return logoUrl;
      }
    };
    _defineProperty(TorusCommunicationProvider, "_defaultState", {
      buttonPosition: "bottom-left",
      currentLoginProvider: null,
      isIFrameFullScreen: false,
      hasEmittedConnection: false,
      torusWidgetVisibility: false,
      initialized: false,
      isLoggedIn: false,
      isPermanentlyDisconnected: false,
      isConnected: false
    });
    TorusInPageProvider = class extends BaseProvider {
      constructor(connectionStream, _ref) {
        let {
          maxEventListeners = 100,
          jsonRpcStreamName = "provider"
        } = _ref;
        super(connectionStream, {
          maxEventListeners,
          jsonRpcStreamName
        });
        _defineProperty(this, "chainId", void 0);
        _defineProperty(this, "selectedAddress", void 0);
        _defineProperty(this, "tryWindowHandle", void 0);
        this._state = _objectSpread$1({}, TorusInPageProvider._defaultState);
        this.selectedAddress = null;
        this.chainId = null;
        this._handleAccountsChanged = this._handleAccountsChanged.bind(this);
        this._handleChainChanged = this._handleChainChanged.bind(this);
        this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this);
        this.on("connect", () => {
          this._state.isConnected = true;
        });
        const jsonRpcNotificationHandler = (payload) => {
          const {
            method,
            params
          } = payload;
          if (method === PROVIDER_NOTIFICATIONS.ACCOUNTS_CHANGED) {
            this._handleAccountsChanged(params);
          } else if (method === PROVIDER_NOTIFICATIONS.UNLOCK_STATE_CHANGED) {
            this._handleUnlockStateChanged(params);
          } else if (method === PROVIDER_NOTIFICATIONS.CHAIN_CHANGED) {
            this._handleChainChanged(params);
          }
        };
        this.jsonRpcConnectionEvents.on("notification", jsonRpcNotificationHandler);
      }
      isConnected() {
        return this._state.isConnected;
      }
      async _initializeState() {
        try {
          const {
            accounts,
            chainId,
            isUnlocked
          } = await this.request({
            method: PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE,
            params: []
          });
          this.emit("connect", {
            chainId
          });
          this._handleChainChanged({
            chainId
          });
          this._handleUnlockStateChanged({
            accounts,
            isUnlocked
          });
          this._handleAccountsChanged(accounts);
        } catch (error) {
          log.error("Torus: Failed to get initial state. Please report this bug.", error);
        } finally {
          log.info("initialized provider state");
          this._state.initialized = true;
          this.emit("_initialized");
        }
      }
      _rpcRequest(payload, callback) {
        let isInternal = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        let cb = callback;
        const _payload = payload;
        if (!Array.isArray(_payload)) {
          if (!_payload.jsonrpc) {
            _payload.jsonrpc = "2.0";
          }
          if (_payload.method === "solana_accounts" || _payload.method === "solana_requestAccounts") {
            cb = (err, res) => {
              this._handleAccountsChanged(res.result || [], _payload.method === "solana_accounts", isInternal);
              callback(err, res);
            };
          } else if (_payload.method === "wallet_getProviderState") {
            this._rpcEngine.handle(payload, cb);
            return;
          }
        }
        this.tryWindowHandle(_payload, cb);
      }
      _handleConnect(chainId) {
        if (!this._state.isConnected) {
          this._state.isConnected = true;
          this.emit("connect", {
            chainId
          });
          log.debug(messages.info.connected(chainId));
        }
      }
      _handleDisconnect(isRecoverable, errorMessage) {
        if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {
          this._state.isConnected = false;
          let error;
          if (isRecoverable) {
            error = new import_eth_rpc_errors.EthereumRpcError(1013, errorMessage || messages.errors.disconnected());
            log.debug(error);
          } else {
            error = new import_eth_rpc_errors.EthereumRpcError(1011, errorMessage || messages.errors.permanentlyDisconnected());
            log.error(error);
            this.chainId = null;
            this._state.accounts = null;
            this.selectedAddress = null;
            this._state.isUnlocked = false;
            this._state.isPermanentlyDisconnected = true;
          }
          this.emit("disconnect", error);
        }
      }
      _handleAccountsChanged(accounts) {
        let isEthAccounts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        let isInternal = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        let finalAccounts = accounts;
        if (!Array.isArray(finalAccounts)) {
          log.error("Torus: Received non-array accounts parameter. Please report this bug.", finalAccounts);
          finalAccounts = [];
        }
        for (const account of accounts) {
          if (typeof account !== "string") {
            log.error("Torus: Received non-string account. Please report this bug.", accounts);
            finalAccounts = [];
            break;
          }
        }
        if (!(0, import_fast_deep_equal.default)(this._state.accounts, finalAccounts)) {
          if (isEthAccounts && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !isInternal) {
            log.error('Torus: "solana_accounts" unexpectedly updated accounts. Please report this bug.', finalAccounts);
          }
          this._state.accounts = finalAccounts;
          this.emit("accountsChanged", finalAccounts);
        }
        if (this.selectedAddress !== finalAccounts[0]) {
          this.selectedAddress = finalAccounts[0] || null;
        }
      }
      _handleChainChanged() {
        let {
          chainId
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!chainId) {
          log.error("Torus: Received invalid network parameters. Please report this bug.", {
            chainId
          });
          return;
        }
        if (chainId === "loading") {
          this._handleDisconnect(true);
        } else {
          this._handleConnect(chainId);
          if (chainId !== this.chainId) {
            this.chainId = chainId;
            if (this._state.initialized) {
              this.emit("chainChanged", this.chainId);
            }
          }
        }
      }
      _handleUnlockStateChanged() {
        let {
          accounts,
          isUnlocked
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (typeof isUnlocked !== "boolean") {
          log.error("Torus: Received invalid isUnlocked parameter. Please report this bug.", {
            isUnlocked
          });
          return;
        }
        if (isUnlocked !== this._state.isUnlocked) {
          this._state.isUnlocked = isUnlocked;
          this._handleAccountsChanged(accounts || []);
        }
      }
    };
    _defineProperty(TorusInPageProvider, "_defaultState", {
      accounts: null,
      isConnected: false,
      isUnlocked: false,
      initialized: false,
      isPermanentlyDisconnected: false,
      hasEmittedConnection: false
    });
    getSiteName = (window2) => {
      const {
        document: document2
      } = window2;
      const siteName = document2.querySelector('head > meta[property="og:site_name"]');
      if (siteName) {
        return siteName.content;
      }
      const metaTitle = document2.querySelector('head > meta[name="title"]');
      if (metaTitle) {
        return metaTitle.content;
      }
      if (document2.title && document2.title.length > 0) {
        return document2.title;
      }
      return window2.location.hostname;
    };
    getSiteMetadata = async () => ({
      name: getSiteName(window),
      icon: await getSiteIcon(window)
    });
    PROVIDER_UNSAFE_METHODS = ["send_transaction", "sign_transaction", "sign_all_transactions", "sign_message", "connect"];
    COMMUNICATION_UNSAFE_METHODS = [COMMUNICATION_JRPC_METHODS.SET_PROVIDER];
    isLocalStorageAvailable = storageAvailable("localStorage");
    (async function preLoadIframe() {
      try {
        if (typeof document === "undefined")
          return;
        const torusIframeHtml = document.createElement("link");
        const {
          torusUrl
        } = await getTorusUrl("production");
        torusIframeHtml.href = "".concat(torusUrl, "/frame");
        torusIframeHtml.crossOrigin = "anonymous";
        torusIframeHtml.type = "text/html";
        torusIframeHtml.rel = "prefetch";
        if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {
          if (torusIframeHtml.relList.supports("prefetch")) {
            document.head.appendChild(torusIframeHtml);
          }
        }
      } catch (error) {
        log.warn(error);
      }
    })();
    Torus = class {
      constructor() {
        let {
          modalZIndex = 99999
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _defineProperty(this, "isInitialized", void 0);
        _defineProperty(this, "torusAlert", void 0);
        _defineProperty(this, "modalZIndex", void 0);
        _defineProperty(this, "alertZIndex", void 0);
        _defineProperty(this, "requestedLoginProvider", void 0);
        _defineProperty(this, "provider", void 0);
        _defineProperty(this, "communicationProvider", void 0);
        _defineProperty(this, "dappStorageKey", void 0);
        _defineProperty(this, "torusAlertContainer", void 0);
        _defineProperty(this, "torusUrl", void 0);
        _defineProperty(this, "torusIframe", void 0);
        _defineProperty(this, "styleLink", void 0);
        this.torusUrl = "";
        this.isInitialized = false;
        this.requestedLoginProvider = null;
        this.modalZIndex = modalZIndex;
        this.alertZIndex = modalZIndex + 1e3;
        this.dappStorageKey = "";
      }
      get isLoggedIn() {
        if (!this.communicationProvider)
          return false;
        return this.communicationProvider.isLoggedIn;
      }
      async init() {
        let {
          buildEnv = TORUS_BUILD_ENV.PRODUCTION,
          enableLogging = false,
          network,
          showTorusButton = false,
          useLocalStorage = false,
          buttonPosition = BUTTON_POSITION.BOTTOM_LEFT,
          apiKey = "torus-default",
          extraParams = {}
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (this.isInitialized)
          throw new Error("Already initialized");
        setAPIKey(apiKey);
        const {
          torusUrl,
          logLevel
        } = await getTorusUrl(buildEnv);
        log.info(torusUrl, "url loaded");
        this.torusUrl = torusUrl;
        log.setDefaultLevel(logLevel);
        if (enableLogging)
          log.enableAll();
        else
          log.disableAll();
        const dappStorageKey = this.handleDappStorageKey(useLocalStorage);
        const torusIframeUrl = new URL(torusUrl);
        if (torusIframeUrl.pathname.endsWith("/"))
          torusIframeUrl.pathname += "frame";
        else
          torusIframeUrl.pathname += "/frame";
        const hashParams = new URLSearchParams();
        if (dappStorageKey)
          hashParams.append("dappStorageKey", dappStorageKey);
        hashParams.append("origin", window.location.origin);
        torusIframeUrl.hash = hashParams.toString();
        this.torusIframe = htmlToElement('<iframe\n        id="torusIframe"\n        class="torusIframe"\n        src="'.concat(torusIframeUrl.href, '"\n        style="display: none; position: fixed; top: 0; right: 0; width: 100%;\n        height: 100%; border: none; border-radius: 0; z-index: ').concat(this.modalZIndex.toString(), '"\n      ></iframe>'));
        this.torusAlertContainer = htmlToElement('<div id="torusAlertContainer" style="display:none; z-index: '.concat(this.alertZIndex.toString(), '"></div>'));
        this.styleLink = htmlToElement('<link href="'.concat(torusUrl, '/css/widget.css" rel="stylesheet" type="text/css">'));
        const handleSetup = async () => {
          return new Promise((resolve, reject) => {
            try {
              window.document.head.appendChild(this.styleLink);
              window.document.body.appendChild(this.torusIframe);
              window.document.body.appendChild(this.torusAlertContainer);
              this.torusIframe.addEventListener("load", async () => {
                const dappMetadata = await getSiteMetadata();
                this.torusIframe.contentWindow.postMessage({
                  buttonPosition,
                  apiKey,
                  network,
                  dappMetadata,
                  extraParams
                }, torusIframeUrl.origin);
                await this._setupWeb3({
                  torusUrl
                });
                if (showTorusButton)
                  this.showTorusButton();
                else
                  this.hideTorusButton();
                this.isInitialized = true;
                window.torus = this;
                resolve();
              });
            } catch (error) {
              reject(error);
            }
          });
        };
        await documentReady();
        await handleSetup();
      }
      async login() {
        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!this.isInitialized)
          throw new Error("Call init() first");
        try {
          this.requestedLoginProvider = params.loginProvider || null;
          if (!this.requestedLoginProvider) {
            this.communicationProvider._displayIframe({
              isFull: true
            });
          }
          const res = await new Promise((resolve, reject) => {
            this.provider._rpcRequest({
              method: "solana_requestAccounts",
              params: [this.requestedLoginProvider, params.login_hint]
            }, getRpcPromiseCallback(resolve, reject));
          });
          if (Array.isArray(res) && res.length > 0) {
            return res;
          }
          throw new Error("Login failed");
        } catch (error) {
          log.error("login failed", error);
          throw error;
        } finally {
          if (this.communicationProvider.isIFrameFullScreen)
            this.communicationProvider._displayIframe();
        }
      }
      async loginWithPrivateKey(loginParams) {
        if (!this.isInitialized)
          throw new Error("Call init() first");
        const {
          privateKey,
          userInfo
        } = loginParams;
        const {
          success
        } = await this.communicationProvider.request({
          method: "login_with_private_key",
          params: {
            privateKey,
            userInfo
          }
        });
        if (!success)
          throw new Error("Login Failed");
      }
      async logout() {
        if (!this.communicationProvider.isLoggedIn)
          throw new Error("Not logged in");
        await this.communicationProvider.request({
          method: COMMUNICATION_JRPC_METHODS.LOGOUT,
          params: []
        });
        this.requestedLoginProvider = null;
      }
      async cleanUp() {
        if (this.communicationProvider.isLoggedIn) {
          await this.logout();
        }
        this.clearInit();
      }
      clearInit() {
        function isElement(element) {
          return element instanceof Element || element instanceof Document;
        }
        if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {
          this.styleLink.remove();
          this.styleLink = void 0;
        }
        if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {
          this.torusIframe.remove();
          this.torusIframe = void 0;
        }
        if (isElement(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer)) {
          this.torusAlert = void 0;
          this.torusAlertContainer.remove();
          this.torusAlertContainer = void 0;
        }
        this.isInitialized = false;
      }
      hideTorusButton() {
        this.communicationProvider.hideTorusButton();
      }
      showTorusButton() {
        this.communicationProvider.showTorusButton();
      }
      async setProvider(params) {
        await this.communicationProvider.request({
          method: COMMUNICATION_JRPC_METHODS.SET_PROVIDER,
          params: _objectSpread({}, params)
        });
      }
      async showWallet(path) {
        let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const instanceId = await this.communicationProvider.request({
          method: COMMUNICATION_JRPC_METHODS.WALLET_INSTANCE_ID,
          params: []
        });
        const finalPath = path ? "/".concat(path) : "";
        const finalUrl = new URL("".concat(this.torusUrl, "/wallet").concat(finalPath));
        finalUrl.searchParams.append("instanceId", instanceId);
        Object.keys(params).forEach((x) => {
          finalUrl.searchParams.append(x, params[x]);
        });
        if (this.dappStorageKey) {
          finalUrl.hash = "#dappStorageKey=".concat(this.dappStorageKey);
        }
        const walletWindow = new PopupHandler({
          url: finalUrl,
          features: getPopupFeatures(FEATURES_DEFAULT_WALLET_WINDOW)
        });
        walletWindow.open();
      }
      async getUserInfo() {
        const userInfoResponse = await this.communicationProvider.request({
          method: COMMUNICATION_JRPC_METHODS.USER_INFO,
          params: []
        });
        return userInfoResponse;
      }
      async initiateTopup(provider, params) {
        if (!this.isInitialized)
          throw new Error("Torus is not initialized");
        const windowId = getWindowId();
        this.communicationProvider._handleWindow(windowId);
        const topupResponse = await this.communicationProvider.request({
          method: COMMUNICATION_JRPC_METHODS.TOPUP,
          params: {
            provider,
            params,
            windowId
          }
        });
        return topupResponse;
      }
      async getAccounts() {
        const response = await this.provider.request({
          method: "getAccounts",
          params: []
        });
        return response;
      }
      async sendTransaction(transaction) {
        const response = await this.provider.request({
          method: "send_transaction",
          params: {
            message: transaction.serialize({
              requireAllSignatures: false
            }).toString("hex")
          }
        });
        return response;
      }
      async signTransaction(transaction) {
        const response = await this.provider.request({
          method: "sign_transaction",
          params: {
            message: transaction.serializeMessage().toString("hex"),
            messageOnly: true
          }
        });
        const parsed = JSON.parse(response);
        const signature = {
          publicKey: new PublicKey(parsed.publicKey),
          signature: Buffer.from(parsed.signature, "hex")
        };
        transaction.addSignature(signature.publicKey, signature.signature);
        return transaction;
      }
      async signAllTransactions(transactions) {
        const encodedMessage = transactions.map((tx) => {
          return tx.serializeMessage().toString("hex");
        });
        const responses = await this.provider.request({
          method: "sign_all_transactions",
          params: {
            message: encodedMessage,
            messageOnly: true
          }
        });
        const signatures = responses.map((item) => {
          const parsed = JSON.parse(item);
          return {
            publicKey: new PublicKey(parsed.publicKey),
            signature: Buffer.from(parsed.signature, "hex")
          };
        });
        transactions.forEach((tx, idx) => {
          tx.addSignature(signatures[idx].publicKey, signatures[idx].signature);
          return tx;
        });
        return transactions;
      }
      async signMessage(data) {
        const response = await this.provider.request({
          method: "sign_message",
          params: {
            data
          }
        });
        return response;
      }
      async getGaslessPublicKey() {
        const response = await this.provider.request({
          method: "get_gasless_public_key",
          params: []
        });
        return response;
      }
      handleDappStorageKey(useLocalStorage) {
        let dappStorageKey = "";
        if (isLocalStorageAvailable && useLocalStorage) {
          const storedKey = window.localStorage.getItem(configuration.localStorageKey);
          if (storedKey)
            dappStorageKey = storedKey;
          else {
            const generatedKey = "torus-app-".concat(getWindowId());
            window.localStorage.setItem(configuration.localStorageKey, generatedKey);
            dappStorageKey = generatedKey;
          }
        }
        this.dappStorageKey = dappStorageKey;
        return dappStorageKey;
      }
      async _setupWeb3(providerParams) {
        log.info("setupWeb3 running");
        const providerStream = new BasePostMessageStream({
          name: "embed_torus",
          target: "iframe_torus",
          targetWindow: this.torusIframe.contentWindow
        });
        const communicationStream = new BasePostMessageStream({
          name: "embed_communication",
          target: "iframe_communication",
          targetWindow: this.torusIframe.contentWindow
        });
        const inPageProvider = new TorusInPageProvider(providerStream, {});
        const communicationProvider = new TorusCommunicationProvider(communicationStream, {});
        inPageProvider.tryWindowHandle = (payload, cb) => {
          const _payload = payload;
          if (!Array.isArray(_payload) && PROVIDER_UNSAFE_METHODS.includes(_payload.method)) {
            if (!this.communicationProvider.isLoggedIn)
              throw new Error("User Not Logged In");
            const windowId = getWindowId();
            communicationProvider._handleWindow(windowId, {
              target: "_blank",
              features: getPopupFeatures(FEATURES_CONFIRM_WINDOW)
            });
            _payload.windowId = windowId;
          }
          inPageProvider._rpcEngine.handle(_payload, cb);
        };
        communicationProvider.tryWindowHandle = (payload, cb) => {
          const _payload = payload;
          if (!Array.isArray(_payload) && COMMUNICATION_UNSAFE_METHODS.includes(_payload.method)) {
            const windowId = getWindowId();
            communicationProvider._handleWindow(windowId, {
              target: "_blank",
              features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW)
            });
            _payload.params.windowId = windowId;
          }
          communicationProvider._rpcEngine.handle(_payload, cb);
        };
        const detectAccountRequestPrototypeModifier = (m) => {
          const originalMethod = inPageProvider[m];
          const self = this;
          inPageProvider[m] = function providerFunc(request, cb) {
            const {
              method,
              params = []
            } = request;
            if (method === "solana_requestAccounts") {
              if (!cb)
                return self.login({
                  loginProvider: params[0]
                });
              self.login({
                loginProvider: params[0]
              }).then((res) => cb(null, res)).catch((err) => cb(err));
            }
            return originalMethod.apply(this, [request, cb]);
          };
        };
        detectAccountRequestPrototypeModifier("request");
        detectAccountRequestPrototypeModifier("sendAsync");
        detectAccountRequestPrototypeModifier("send");
        const proxiedInPageProvider = new Proxy(inPageProvider, {
          deleteProperty: () => true
        });
        const proxiedCommunicationProvider = new Proxy(communicationProvider, {
          deleteProperty: () => true
        });
        this.provider = proxiedInPageProvider;
        this.communicationProvider = proxiedCommunicationProvider;
        await Promise.all([inPageProvider._initializeState(), communicationProvider._initializeState(_objectSpread(_objectSpread({}, providerParams), {}, {
          dappStorageKey: this.dappStorageKey,
          torusAlertContainer: this.torusAlertContainer,
          torusIframe: this.torusIframe
        }))]);
        log.debug("Torus - injected provider");
      }
    };
  }
});

// node_modules/@web3auth/torus-solana-adapter/dist/torusSolanaAdapter.esm.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var import_loglevel2, SolanaWalletAdapter;
var init_torusSolanaAdapter_esm = __esm({
  "node_modules/@web3auth/torus-solana-adapter/dist/torusSolanaAdapter.esm.js"() {
    init_defineProperty();
    init_solanaEmbed_esm();
    init_base_esm();
    init_solanaProvider_esm();
    import_loglevel2 = __toESM(require_loglevel());
    SolanaWalletAdapter = class extends BaseAdapter {
      constructor() {
        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        super();
        _defineProperty(this, "name", WALLET_ADAPTERS.TORUS_SOLANA);
        _defineProperty(this, "adapterNamespace", ADAPTER_NAMESPACES.SOLANA);
        _defineProperty(this, "currentChainNamespace", CHAIN_NAMESPACES.SOLANA);
        _defineProperty(this, "type", ADAPTER_CATEGORY.EXTERNAL);
        _defineProperty(this, "status", ADAPTER_STATUS.NOT_READY);
        _defineProperty(this, "torusInstance", null);
        _defineProperty(this, "torusWalletOptions", void 0);
        _defineProperty(this, "initParams", void 0);
        _defineProperty(this, "loginSettings", {});
        _defineProperty(this, "solanaProvider", null);
        _defineProperty(this, "rehydrated", false);
        this.torusWalletOptions = params.adapterSettings || {};
        this.initParams = params.initParams || {};
        this.loginSettings = params.loginSettings || {};
        this.chainConfig = params.chainConfig || null;
      }
      get provider() {
        if (this.status === ADAPTER_STATUS.CONNECTED && this.solanaProvider) {
          var _this$solanaProvider;
          return ((_this$solanaProvider = this.solanaProvider) === null || _this$solanaProvider === void 0 ? void 0 : _this$solanaProvider.provider) || null;
        }
        return null;
      }
      set provider(_) {
        throw new Error("Not implemented");
      }
      async init(options) {
        super.checkInitializationRequirements();
        let network;
        if (!this.chainConfig) {
          this.chainConfig = getChainConfig(CHAIN_NAMESPACES.SOLANA, "0x1");
          const {
            blockExplorer,
            displayName,
            ticker,
            tickerName,
            rpcTarget,
            chainId
          } = this.chainConfig;
          network = {
            chainId,
            rpcTarget,
            blockExplorerUrl: blockExplorer,
            displayName,
            ticker,
            tickerName,
            logo: ""
          };
        } else {
          const {
            chainId,
            blockExplorer,
            displayName,
            rpcTarget,
            ticker,
            tickerName
          } = this.chainConfig;
          network = {
            chainId,
            rpcTarget,
            blockExplorerUrl: blockExplorer,
            displayName,
            tickerName,
            ticker,
            logo: ""
          };
        }
        this.torusInstance = new Torus(this.torusWalletOptions);
        await this.torusInstance.init(_objectSpread2(_objectSpread2({
          showTorusButton: false
        }, this.initParams), {}, {
          network
        }));
        this.solanaProvider = new TorusInjectedProvider({
          config: {
            chainConfig: this.chainConfig
          }
        });
        this.status = ADAPTER_STATUS.READY;
        this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.TORUS_SOLANA);
        try {
          if (options.autoConnect) {
            this.rehydrated = true;
            await this.connect();
          }
        } catch (error) {
          import_loglevel2.default.error("Failed to connect with cached torus solana provider", error);
          this.emit(ADAPTER_EVENTS.ERRORED, error);
        }
      }
      async connect() {
        super.checkConnectionRequirements();
        if (!this.torusInstance)
          throw WalletInitializationError.notReady("Torus wallet is not initialized");
        if (!this.solanaProvider)
          throw WalletInitializationError.notReady("Torus wallet is not initialized");
        this.status = ADAPTER_STATUS.CONNECTING;
        this.emit(ADAPTER_EVENTS.CONNECTING, {
          adapter: WALLET_ADAPTERS.TORUS_SOLANA
        });
        try {
          await this.torusInstance.login(this.loginSettings);
          await this.solanaProvider.setupProvider(this.torusInstance.provider);
          this.status = ADAPTER_STATUS.CONNECTED;
          this.torusInstance.showTorusButton();
          this.emit(ADAPTER_STATUS.CONNECTED, {
            adapter: WALLET_ADAPTERS.TORUS_SOLANA,
            reconnected: this.rehydrated
          });
          return this.provider;
        } catch (error) {
          this.status = ADAPTER_STATUS.READY;
          this.rehydrated = false;
          this.emit(ADAPTER_EVENTS.ERRORED, error);
          throw WalletLoginError.connectionError("Failed to login with torus solana wallet");
        }
      }
      async disconnect() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          cleanup: false
        };
        if (this.status !== ADAPTER_STATUS.CONNECTED)
          throw WalletLoginError.notConnectedError("Not connected with wallet");
        if (!this.torusInstance)
          throw WalletInitializationError.notReady("Torus wallet is not initialized");
        await this.torusInstance.logout();
        if (options.cleanup) {
          this.status = ADAPTER_STATUS.NOT_READY;
          this.torusInstance = null;
          this.solanaProvider = null;
        } else {
          this.status = ADAPTER_STATUS.READY;
        }
        this.emit(ADAPTER_EVENTS.DISCONNECTED);
      }
      async getUserInfo() {
        if (this.status !== ADAPTER_STATUS.CONNECTED)
          throw WalletLoginError.notConnectedError("Not connected with wallet");
        if (!this.torusInstance)
          throw WalletInitializationError.notReady("Torus wallet is not initialized");
        const userInfo = await this.torusInstance.getUserInfo();
        return userInfo;
      }
      setAdapterSettings(_) {
      }
    };
  }
});
init_torusSolanaAdapter_esm();
export {
  SolanaWalletAdapter
};
//# sourceMappingURL=torusSolanaAdapter.esm-VBNHNG5L.js.map
