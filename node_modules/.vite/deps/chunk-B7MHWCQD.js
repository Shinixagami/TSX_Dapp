import {
  require_sha3
} from "./chunk-VG2MP6HV.js";
import {
  require_bn
} from "./chunk-FWQTTRC5.js";
import {
  __commonJS,
  __esm,
  __export,
  __reExport,
  __toESM
} from "./chunk-JGDUASYK.js";

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow3(name) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow3;
    function getFromWindowOrThrow3(name) {
      const res = getFromWindow3(name);
      if (!res) {
        throw new Error(`${name} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow3;
    function getDocumentOrThrow3() {
      return getFromWindowOrThrow3("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow3;
    function getDocument3() {
      return getFromWindow3("document");
    }
    exports.getDocument = getDocument3;
    function getNavigatorOrThrow3() {
      return getFromWindowOrThrow3("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow3;
    function getNavigator3() {
      return getFromWindow3("navigator");
    }
    exports.getNavigator = getNavigator3;
    function getLocationOrThrow3() {
      return getFromWindowOrThrow3("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow3;
    function getLocation3() {
      return getFromWindow3("location");
    }
    exports.getLocation = getLocation3;
    function getCryptoOrThrow3() {
      return getFromWindowOrThrow3("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow3;
    function getCrypto3() {
      return getFromWindow3("crypto");
    }
    exports.getCrypto = getCrypto3;
    function getLocalStorageOrThrow3() {
      return getFromWindowOrThrow3("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow3;
    function getLocalStorage3() {
      return getFromWindow3("localStorage");
    }
    exports.getLocalStorage = getLocalStorage3;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs();
    function getWindowMetadata2() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i = 0; i < links.length; i++) {
          const link = links[i];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i = 0; i < metaTags.length; i++) {
          const tag = metaTags[i];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name2) {
          name2 = doc.title;
        }
        return name2;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata2;
  }
});

// node_modules/detect-browser/es/index.js
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }
  var version = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode3 = typeof process !== "undefined" && process.version;
  return isNode3 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}
var __spreadArrays, BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, SEARCHBOX_UA_REGEX, SEARCHBOT_OS_REGEX, REQUIRED_VERSION_PARTS, userAgentRules, operatingSystemRules;
var init_es = __esm({
  "node_modules/detect-browser/es/index.js"() {
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    BrowserInfo = function() {
      function BrowserInfo2(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.type = "browser";
      }
      return BrowserInfo2;
    }();
    NodeInfo = function() {
      function NodeInfo2(version) {
        this.version = version;
        this.type = "node";
        this.name = "node";
        this.os = process.platform;
      }
      return NodeInfo2;
    }();
    SearchBotDeviceInfo = function() {
      function SearchBotDeviceInfo2(name, version, os, bot) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.bot = bot;
        this.type = "bot-device";
      }
      return SearchBotDeviceInfo2;
    }();
    BotInfo = function() {
      function BotInfo2() {
        this.type = "bot";
        this.bot = true;
        this.name = "bot";
        this.version = null;
        this.os = null;
      }
      return BotInfo2;
    }();
    ReactNativeInfo = function() {
      function ReactNativeInfo2() {
        this.type = "react-native";
        this.name = "react-native";
        this.version = null;
        this.os = null;
      }
      return ReactNativeInfo2;
    }();
    SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
    SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
    REQUIRED_VERSION_PARTS = 3;
    userAgentRules = [
      ["aol", /AOLShield\/([0-9\._]+)/],
      ["edge", /Edge\/([0-9\._]+)/],
      ["edge-ios", /EdgiOS\/([0-9\._]+)/],
      ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
      ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
      ["samsung", /SamsungBrowser\/([0-9\.]+)/],
      ["silk", /\bSilk\/([0-9._-]+)\b/],
      ["miui", /MiuiBrowser\/([0-9\.]+)$/],
      ["beaker", /BeakerBrowser\/([0-9\.]+)/],
      ["edge-chromium", /EdgA?\/([0-9\.]+)/],
      [
        "chromium-webview",
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
      ],
      ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
      ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
      ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
      ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
      ["fxios", /FxiOS\/([0-9\.]+)/],
      ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
      ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
      ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
      ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
      ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
      ["ie", /MSIE\s(7\.0)/],
      ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
      ["android", /Android\s([0-9\.]+)/],
      ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
      ["safari", /Version\/([0-9\._]+).*Safari/],
      ["facebook", /FBAV\/([0-9\.]+)/],
      ["instagram", /Instagram\s([0-9\.]+)/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
      ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
      ["searchbot", SEARCHBOX_UA_REGEX]
    ];
    operatingSystemRules = [
      ["iOS", /iP(hone|od|ad)/],
      ["Android OS", /Android/],
      ["BlackBerry OS", /BlackBerry|BB10/],
      ["Windows Mobile", /IEMobile/],
      ["Amazon OS", /Kindle/],
      ["Windows 3.11", /Win16/],
      ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
      ["Windows 98", /(Windows 98)|(Win98)/],
      ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
      ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
      ["Windows Server 2003", /(Windows NT 5.2)/],
      ["Windows Vista", /(Windows NT 6.0)/],
      ["Windows 7", /(Windows NT 6.1)/],
      ["Windows 8", /(Windows NT 6.2)/],
      ["Windows 8.1", /(Windows NT 6.3)/],
      ["Windows 10", /(Windows NT 10.0)/],
      ["Windows ME", /Windows ME/],
      ["Open BSD", /OpenBSD/],
      ["Sun OS", /SunOS/],
      ["Chrome OS", /CrOS/],
      ["Linux", /(Linux)|(X11)/],
      ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
      ["QNX", /QNX/],
      ["BeOS", /BeOS/],
      ["OS/2", /OS\/2/]
    ];
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/browser.js
function detectEnv(userAgent) {
  return detect(userAgent);
}
function detectOS2() {
  const env3 = detectEnv();
  return env3 && env3.os ? env3.os : void 0;
}
function isAndroid() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os = detectOS2();
  return os ? isAndroid() || isIOS() : false;
}
function isNode() {
  const env3 = detectEnv();
  const result = env3 && env3.name ? env3.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser() {
  const result = !isNode() && !!getNavigator2();
  return result;
}
function getClientMeta() {
  return windowMetadata.getWindowMetadata();
}
var windowMetadata, windowGetters, getFromWindow2, getFromWindowOrThrow2, getDocumentOrThrow2, getDocument2, getNavigatorOrThrow2, getNavigator2, getLocationOrThrow2, getLocation2, getCryptoOrThrow2, getCrypto2, getLocalStorageOrThrow2, getLocalStorage2;
var init_browser = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/browser.js"() {
    windowMetadata = __toESM(require_cjs2());
    windowGetters = __toESM(require_cjs());
    init_es();
    getFromWindow2 = windowGetters.getFromWindow;
    getFromWindowOrThrow2 = windowGetters.getFromWindowOrThrow;
    getDocumentOrThrow2 = windowGetters.getDocumentOrThrow;
    getDocument2 = windowGetters.getDocument;
    getNavigatorOrThrow2 = windowGetters.getNavigatorOrThrow;
    getNavigator2 = windowGetters.getNavigator;
    getLocationOrThrow2 = windowGetters.getLocationOrThrow;
    getLocation2 = windowGetters.getLocation;
    getCryptoOrThrow2 = windowGetters.getCryptoOrThrow;
    getCrypto2 = windowGetters.getCrypto;
    getLocalStorageOrThrow2 = windowGetters.getLocalStorageOrThrow;
    getLocalStorage2 = windowGetters.getLocalStorage;
  }
});

// node_modules/@walletconnect/safe-json/dist/esm/index.js
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSON.parse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSON.stringify(value);
}
var init_esm = __esm({
  "node_modules/@walletconnect/safe-json/dist/esm/index.js"() {
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/json.js
var safeJsonParse2, safeJsonStringify2;
var init_json = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/json.js"() {
    init_esm();
    safeJsonParse2 = safeJsonParse;
    safeJsonStringify2 = safeJsonStringify;
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/local.js
function setLocal(key, data) {
  const raw = safeJsonStringify2(data);
  const local = getLocalStorage2();
  if (local) {
    local.setItem(key, raw);
  }
}
function getLocal(key) {
  let data = null;
  let raw = null;
  const local = getLocalStorage2();
  if (local) {
    raw = local.getItem(key);
  }
  data = raw ? safeJsonParse2(raw) : raw;
  return data;
}
function removeLocal(key) {
  const local = getLocalStorage2();
  if (local) {
    local.removeItem(key);
  }
}
var init_local = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/local.js"() {
    init_json();
    init_browser();
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/mobile.js
function formatIOSMobile(uri, entry) {
  const encodedUri = encodeURIComponent(uri);
  return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
}
function saveMobileLinkInfo(data) {
  const focusUri = data.href.split("?")[0];
  setLocal(mobileLinkChoiceKey, Object.assign(Object.assign({}, data), { href: focusUri }));
}
function getMobileRegistryEntry(registry, name) {
  return registry.filter((entry) => entry.name.toLowerCase().includes(name.toLowerCase()))[0];
}
function getMobileLinkRegistry(registry, whitelist) {
  let links = registry;
  if (whitelist) {
    links = whitelist.map((name) => getMobileRegistryEntry(registry, name)).filter(Boolean);
  }
  return links;
}
var mobileLinkChoiceKey;
var init_mobile = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/mobile.js"() {
    init_local();
    mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/registry.js
function getWalletRegistryUrl() {
  return API_URL + "/api/v2/wallets";
}
function getDappRegistryUrl() {
  return API_URL + "/api/v2/dapps";
}
function formatMobileRegistryEntry(entry, platform = "mobile") {
  var _a;
  return {
    name: entry.name || "",
    shortName: entry.metadata.shortName || "",
    color: entry.metadata.colors.primary || "",
    logo: (_a = entry.image_url.sm) !== null && _a !== void 0 ? _a : "",
    universalLink: entry[platform].universal || "",
    deepLink: entry[platform].native || ""
  };
}
function formatMobileRegistry(registry, platform = "mobile") {
  return Object.values(registry).filter((entry) => !!entry[platform].universal || !!entry[platform].native).map((entry) => formatMobileRegistryEntry(entry, platform));
}
var API_URL;
var init_registry = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/registry.js"() {
    API_URL = "https://registry.walletconnect.com";
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  detectEnv: () => detectEnv,
  detectOS: () => detectOS2,
  formatIOSMobile: () => formatIOSMobile,
  formatMobileRegistry: () => formatMobileRegistry,
  formatMobileRegistryEntry: () => formatMobileRegistryEntry,
  getClientMeta: () => getClientMeta,
  getCrypto: () => getCrypto2,
  getCryptoOrThrow: () => getCryptoOrThrow2,
  getDappRegistryUrl: () => getDappRegistryUrl,
  getDocument: () => getDocument2,
  getDocumentOrThrow: () => getDocumentOrThrow2,
  getFromWindow: () => getFromWindow2,
  getFromWindowOrThrow: () => getFromWindowOrThrow2,
  getLocal: () => getLocal,
  getLocalStorage: () => getLocalStorage2,
  getLocalStorageOrThrow: () => getLocalStorageOrThrow2,
  getLocation: () => getLocation2,
  getLocationOrThrow: () => getLocationOrThrow2,
  getMobileLinkRegistry: () => getMobileLinkRegistry,
  getMobileRegistryEntry: () => getMobileRegistryEntry,
  getNavigator: () => getNavigator2,
  getNavigatorOrThrow: () => getNavigatorOrThrow2,
  getWalletRegistryUrl: () => getWalletRegistryUrl,
  isAndroid: () => isAndroid,
  isBrowser: () => isBrowser,
  isIOS: () => isIOS,
  isMobile: () => isMobile,
  isNode: () => isNode,
  mobileLinkChoiceKey: () => mobileLinkChoiceKey,
  removeLocal: () => removeLocal,
  safeJsonParse: () => safeJsonParse2,
  safeJsonStringify: () => safeJsonStringify2,
  saveMobileLinkInfo: () => saveMobileLinkInfo,
  setLocal: () => setLocal
});
var init_esm2 = __esm({
  "node_modules/@walletconnect/browser-utils/dist/esm/index.js"() {
    init_browser();
    init_json();
    init_local();
    init_mobile();
    init_registry();
  }
});

// node_modules/@walletconnect/utils/dist/esm/constants.js
var reservedEvents, signingMethods, infuraNetworks;
var init_constants = __esm({
  "node_modules/@walletconnect/utils/dist/esm/constants.js"() {
    reservedEvents = [
      "session_request",
      "session_update",
      "exchange_key",
      "connect",
      "disconnect",
      "display_uri",
      "modal_closed",
      "transport_open",
      "transport_close",
      "transport_error"
    ];
    signingMethods = [
      "eth_sendTransaction",
      "eth_signTransaction",
      "eth_sign",
      "eth_signTypedData",
      "eth_signTypedData_v1",
      "eth_signTypedData_v2",
      "eth_signTypedData_v3",
      "eth_signTypedData_v4",
      "personal_sign",
      "wallet_addEthereumChain",
      "wallet_switchEthereumChain",
      "wallet_getPermissions",
      "wallet_requestPermissions",
      "wallet_registerOnboarding",
      "wallet_watchAsset",
      "wallet_scanQRCode"
    ];
    infuraNetworks = {
      1: "mainnet",
      3: "ropsten",
      4: "rinkeby",
      5: "goerli",
      42: "kovan"
    };
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports, module) {
    module.exports = isTypedArray2;
    isTypedArray2.strict = isStrictTypedArray;
    isTypedArray2.loose = isLooseTypedArray;
    var toString = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray2(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports, module) {
    var isTypedArray2 = require_is_typedarray().strict;
    module.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray2(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// node_modules/@walletconnect/encoding/dist/esm/index.js
function bufferToArray(buf) {
  return new Uint8Array(buf);
}
function bufferToHex(buf, prefixed = false) {
  const hex = buf.toString(ENC_HEX);
  return prefixed ? addHexPrefix(hex) : hex;
}
function bufferToUtf8(buf) {
  return buf.toString(ENC_UTF8);
}
function arrayToBuffer(arr) {
  return (0, import_typedarray_to_buffer.default)(arr);
}
function arrayToHex(arr, prefixed = false) {
  return bufferToHex(arrayToBuffer(arr), prefixed);
}
function arrayToUtf8(arr) {
  return bufferToUtf8(arrayToBuffer(arr));
}
function hexToBuffer(hex) {
  return Buffer.from(removeHexPrefix(hex), ENC_HEX);
}
function hexToArray(hex) {
  return bufferToArray(hexToBuffer(hex));
}
function utf8ToBuffer(utf8) {
  return Buffer.from(utf8, ENC_UTF8);
}
function utf8ToArray(utf8) {
  return bufferToArray(utf8ToBuffer(utf8));
}
function utf8ToHex(utf8, prefixed = false) {
  return bufferToHex(utf8ToBuffer(utf8), prefixed);
}
function isHexString(str, length) {
  if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && str.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function concatArrays(...args) {
  let result = [];
  args.forEach((arg) => result = result.concat(Array.from(arg)));
  return new Uint8Array([...result]);
}
function calcByteLength(length, byteSize = 8) {
  const remainder = length % byteSize;
  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
}
function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
  return padLeft(str, calcByteLength(str.length, byteSize), padding);
}
function padLeft(str, length, padding = STRING_ZERO) {
  return padString(str, length, true, padding);
}
function removeHexPrefix(hex) {
  return hex.replace(/^0x/, "");
}
function addHexPrefix(hex) {
  return hex.startsWith("0x") ? hex : `0x${hex}`;
}
function sanitizeHex(hex) {
  hex = removeHexPrefix(hex);
  hex = sanitizeBytes(hex, 2);
  if (hex) {
    hex = addHexPrefix(hex);
  }
  return hex;
}
function removeHexLeadingZeros(hex) {
  const prefixed = hex.startsWith("0x");
  hex = removeHexPrefix(hex);
  hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
  return prefixed ? addHexPrefix(hex) : hex;
}
function padString(str, length, left, padding = STRING_ZERO) {
  const diff = length - str.length;
  let result = str;
  if (diff > 0) {
    const pad = padding.repeat(diff);
    result = left ? pad + str : str + pad;
  }
  return result;
}
var import_is_typedarray, import_typedarray_to_buffer, ENC_HEX, ENC_UTF8, STRING_ZERO;
var init_esm3 = __esm({
  "node_modules/@walletconnect/encoding/dist/esm/index.js"() {
    import_is_typedarray = __toESM(require_is_typedarray());
    import_typedarray_to_buffer = __toESM(require_typedarray_to_buffer());
    ENC_HEX = "hex";
    ENC_UTF8 = "utf8";
    STRING_ZERO = "0";
  }
});

// node_modules/@walletconnect/utils/dist/esm/encoding.js
function convertArrayBufferToBuffer(arrBuf) {
  return arrayToBuffer(new Uint8Array(arrBuf));
}
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return arrayToHex(new Uint8Array(arrBuf), !noPrefix);
}
function convertBufferToArrayBuffer(buf) {
  return bufferToArray(buf).buffer;
}
function convertUtf8ToBuffer(utf8) {
  return utf8ToBuffer(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return utf8ToHex(utf8, !noPrefix);
}
function convertHexToArrayBuffer(hex) {
  return hexToArray(hex).buffer;
}
function convertNumberToHex(num, noPrefix) {
  const hex = removeHexPrefix(sanitizeHex(new import_bn.default(num).toString(16)));
  return noPrefix ? hex : addHexPrefix(hex);
}
var import_bn;
var init_encoding = __esm({
  "node_modules/@walletconnect/utils/dist/esm/encoding.js"() {
    import_bn = __toESM(require_bn());
    init_esm3();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR, INVALID_REQUEST, METHOD_NOT_FOUND, INVALID_PARAMS, INTERNAL_ERROR, SERVER_ERROR, RESERVED_ERROR_CODES, SERVER_ERROR_CODE_RANGE, STANDARD_ERROR_MAP, DEFAULT_ERROR;
var init_constants2 = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js"() {
    PARSE_ERROR = "PARSE_ERROR";
    INVALID_REQUEST = "INVALID_REQUEST";
    METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
    INVALID_PARAMS = "INVALID_PARAMS";
    INTERNAL_ERROR = "INTERNAL_ERROR";
    SERVER_ERROR = "SERVER_ERROR";
    RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
    SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
    STANDARD_ERROR_MAP = {
      [PARSE_ERROR]: { code: -32700, message: "Parse error" },
      [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
      [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
      [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
      [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
      [SERVER_ERROR]: { code: -32e3, message: "Server error" }
    };
    DEFAULT_ERROR = SERVER_ERROR;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code) {
  return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
  return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
  return typeof code === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e) => e.code === code);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e, url, type) {
  return e.message.includes("getaddrinfo ENOTFOUND") || e.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e;
}
var init_error = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js"() {
    init_constants2();
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto2() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto2;
    function getSubtleCrypto2() {
      const browserCrypto = getBrowerCrypto2();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto2;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto2() && !!getSubtleCrypto2();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative;
    function isNode3() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode3;
    function isBrowser2() {
      return !isReactNative() && !isNode3();
    }
    exports.isBrowser = isBrowser2;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !exports2.hasOwnProperty(p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_crypto(), exports);
    __exportStar(require_env(), exports);
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment, isNodeJs;
var init_env = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js"() {
    import_environment = __toESM(require_cjs3());
    __reExport(env_exports, __toESM(require_cjs3()));
    isNodeJs = import_environment.isNode;
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId() {
  const date = Date.now() * Math.pow(10, 3);
  const extra = Math.floor(Math.random() * Math.pow(10, 3));
  return date + extra;
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error, data) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data)
  };
}
function formatErrorMessage(error, data) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (typeof data !== "undefined") {
    error.data = data;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}
var init_format = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js"() {
    init_error();
    init_constants2();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x) => x.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}
var init_routing = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js"() {
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/jsonrpc.js
var init_jsonrpc = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/jsonrpc.js"() {
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js
var IEvents;
var init_misc = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js"() {
    IEvents = class {
    };
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js
var IJsonRpcConnection, IBaseJsonRpcProvider, IJsonRpcProvider;
var init_provider = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js"() {
    init_misc();
    IJsonRpcConnection = class extends IEvents {
      constructor(opts) {
        super();
      }
    };
    IBaseJsonRpcProvider = class extends IEvents {
      constructor() {
        super();
      }
    };
    IJsonRpcProvider = class extends IBaseJsonRpcProvider {
      constructor(connection) {
        super();
      }
    };
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/validator.js
var init_validator = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/validator.js"() {
  }
});

// node_modules/@walletconnect/jsonrpc-types/dist/esm/index.js
var init_esm4 = __esm({
  "node_modules/@walletconnect/jsonrpc-types/dist/esm/index.js"() {
    init_jsonrpc();
    init_misc();
    init_provider();
    init_validator();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js
var init_types = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js"() {
    init_esm4();
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}
var HTTP_REGEX, WS_REGEX;
var init_url = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js"() {
    HTTP_REGEX = "^https?:";
    WS_REGEX = "^wss?:";
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}
var init_validators = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js"() {
  }
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => IBaseJsonRpcProvider,
  IEvents: () => IEvents,
  IJsonRpcConnection: () => IJsonRpcConnection,
  IJsonRpcProvider: () => IJsonRpcProvider,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});
var init_esm5 = __esm({
  "node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js"() {
    init_constants2();
    init_error();
    init_env();
    __reExport(esm_exports4, env_exports);
    init_format();
    init_routing();
    init_types();
    init_url();
    init_validators();
  }
});

// node_modules/@walletconnect/utils/dist/esm/misc.js
function sanitizeHex2(hex) {
  return sanitizeHex(hex);
}
function removeHexLeadingZeros2(hex) {
  return removeHexLeadingZeros(addHexPrefix(hex));
}
function uuid() {
  const result = ((a, b) => {
    for (b = a = ""; a++ < 36; b += a * 51 & 52 ? (a ^ 15 ? 8 ^ Math.random() * (a ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b;
  })();
  return result;
}
function getInfuraRpcUrl(chainId, infuraId) {
  let rpcUrl;
  const network = infuraNetworks[chainId];
  if (network) {
    rpcUrl = `https://${network}.infura.io/v3/${infuraId}`;
  }
  return rpcUrl;
}
function getRpcUrl(chainId, rpc) {
  let rpcUrl;
  const infuraUrl = getInfuraRpcUrl(chainId, rpc.infuraId);
  if (rpc.custom && rpc.custom[chainId]) {
    rpcUrl = rpc.custom[chainId];
  } else if (infuraUrl) {
    rpcUrl = infuraUrl;
  }
  return rpcUrl;
}
var payloadId2;
var init_misc2 = __esm({
  "node_modules/@walletconnect/utils/dist/esm/misc.js"() {
    init_esm3();
    init_esm5();
    init_constants();
    payloadId2 = payloadId;
  }
});

// node_modules/@walletconnect/utils/dist/esm/validators.js
function isEmptyString(value) {
  return value === "" || typeof value === "string" && value.trim() === "";
}
function isEmptyArray(array) {
  return !(array && array.length);
}
function isHexString2(value, length) {
  return isHexString(value, length);
}
function isJsonRpcRequest2(object) {
  return typeof object.method !== "undefined";
}
function isJsonRpcResponseSuccess(object) {
  return typeof object.result !== "undefined";
}
function isJsonRpcResponseError(object) {
  return typeof object.error !== "undefined";
}
function isInternalEvent(object) {
  return typeof object.event !== "undefined";
}
function isReservedEvent(event) {
  return reservedEvents.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request) {
  if (request.method.startsWith("wc_")) {
    return true;
  }
  if (signingMethods.includes(request.method)) {
    return false;
  }
  return true;
}
var init_validators2 = __esm({
  "node_modules/@walletconnect/utils/dist/esm/validators.js"() {
    init_esm3();
    init_constants();
  }
});

// node_modules/@walletconnect/utils/dist/esm/ethereum.js
function toChecksumAddress(address) {
  address = removeHexPrefix(address.toLowerCase());
  const hash = removeHexPrefix((0, import_js_sha3.keccak_256)(convertUtf8ToBuffer(address)));
  let checksum = "";
  for (let i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) > 7) {
      checksum += address[i].toUpperCase();
    } else {
      checksum += address[i];
    }
  }
  return addHexPrefix(checksum);
}
function parsePersonalSign(params) {
  if (!isEmptyArray(params) && !isHexString2(params[0])) {
    params[0] = convertUtf8ToHex(params[0]);
  }
  return params;
}
function parseTransactionData(txData) {
  if (typeof txData.type !== "undefined" && txData.type !== "0")
    return txData;
  if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
    throw new Error(`Transaction object must include a valid 'from' value.`);
  }
  function parseHexValues(value) {
    let result = value;
    if (typeof value === "number" || typeof value === "string" && !isEmptyString(value)) {
      if (!isHexString2(value)) {
        result = convertNumberToHex(value);
      } else if (typeof value === "string") {
        result = sanitizeHex2(value);
      }
    }
    if (typeof result === "string") {
      result = removeHexLeadingZeros2(result);
    }
    return result;
  }
  const txDataRPC = {
    from: sanitizeHex2(txData.from),
    to: typeof txData.to === "undefined" ? void 0 : sanitizeHex2(txData.to),
    gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
    gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
    value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
    nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
    data: typeof txData.data === "undefined" ? "" : sanitizeHex2(txData.data) || "0x"
  };
  const prunable = ["gasPrice", "gas", "value", "nonce"];
  Object.keys(txDataRPC).forEach((key) => {
    if ((typeof txDataRPC[key] === "undefined" || typeof txDataRPC[key] === "string" && !txDataRPC[key].trim().length) && prunable.includes(key)) {
      delete txDataRPC[key];
    }
  });
  return txDataRPC;
}
var import_js_sha3, isValidAddress;
var init_ethereum = __esm({
  "node_modules/@walletconnect/utils/dist/esm/ethereum.js"() {
    import_js_sha3 = __toESM(require_sha3());
    init_esm3();
    init_encoding();
    init_misc2();
    init_validators2();
    isValidAddress = (address) => {
      if (!address) {
        return false;
      } else if (address.toLowerCase().substring(0, 2) !== "0x") {
        return false;
      } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
        return false;
      } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
        return true;
      } else {
        return address === toChecksumAddress(address);
      }
    };
  }
});

// node_modules/@walletconnect/utils/dist/esm/payload.js
function formatRpcError(error) {
  const message = error.message || "Failed or Rejected Request";
  let code = -32e3;
  if (error && !error.code) {
    switch (message) {
      case "Parse error":
        code = -32700;
        break;
      case "Invalid request":
        code = -32600;
        break;
      case "Method not found":
        code = -32601;
        break;
      case "Invalid params":
        code = -32602;
        break;
      case "Internal error":
        code = -32603;
        break;
      default:
        code = -32e3;
        break;
    }
  }
  const result = {
    code,
    message
  };
  return result;
}
var init_payload = __esm({
  "node_modules/@walletconnect/utils/dist/esm/payload.js"() {
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports, module) {
    "use strict";
    module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports, module) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp(token, "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return decodeURIComponent(components.join(""));
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher);
        for (var i = 1; i < tokens.length; i++) {
          input = decodeComponents(tokens, i).join("");
          tokens = input.match(singleMatcher);
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries = Object.keys(replaceMap);
      for (var i = 0; i < entries.length; i++) {
        var key = entries[i];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports, module) {
    "use strict";
    module.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode(key, options), "=", encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse2(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k of Object.keys(value)) {
            value[k] = parseValue(value[k], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse2;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x) => x.length > 0).join("&");
    };
    exports.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash] = splitOnFirst(input, "#");
      return Object.assign({
        url: url.split("?")[0] || "",
        query: parse2(extract(input), options)
      }, options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {});
    };
    exports.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(input.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash = `#${encode(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash}`;
    };
  }
});

// node_modules/@walletconnect/utils/dist/esm/url.js
function getQueryString(url) {
  const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
  const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
  return queryString;
}
function appendToQueryString(queryString, newQueryParams) {
  let queryParams = parseQueryString(queryString);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString = formatQueryString(queryParams);
  return queryString;
}
function parseQueryString(queryString) {
  return queryStringUtils.parse(queryString);
}
function formatQueryString(queryParams) {
  return queryStringUtils.stringify(queryParams);
}
var queryStringUtils;
var init_url2 = __esm({
  "node_modules/@walletconnect/utils/dist/esm/url.js"() {
    queryStringUtils = __toESM(require_query_string());
  }
});

// node_modules/@walletconnect/utils/dist/esm/session.js
function isWalletConnectSession(object) {
  return typeof object.bridge !== "undefined";
}
function parseWalletConnectUri(str) {
  const pathStart = str.indexOf(":");
  const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
  const protocol = str.substring(0, pathStart);
  const path = str.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path2) {
    const separator = "@";
    const values = path2.split(separator);
    const requiredParams2 = {
      handshakeTopic: values[0],
      version: parseInt(values[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path);
  const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
  function parseQueryParams(queryString2) {
    const result2 = parseQueryString(queryString2);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString);
  const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
  return result;
}
var init_session = __esm({
  "node_modules/@walletconnect/utils/dist/esm/session.js"() {
    init_url2();
  }
});

// node_modules/@walletconnect/utils/dist/esm/index.js
var init_esm6 = __esm({
  "node_modules/@walletconnect/utils/dist/esm/index.js"() {
    init_esm2();
    init_constants();
    init_encoding();
    init_ethereum();
    init_misc2();
    init_payload();
    init_session();
    init_url2();
    init_validators2();
  }
});

// node_modules/@walletconnect/socket-transport/dist/esm/network.js
var NetworkMonitor, network_default;
var init_network = __esm({
  "node_modules/@walletconnect/socket-transport/dist/esm/network.js"() {
    NetworkMonitor = class {
      constructor() {
        this._eventEmitters = [];
        if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
          window.addEventListener("online", () => this.trigger("online"));
          window.addEventListener("offline", () => this.trigger("offline"));
        }
      }
      on(event, callback) {
        this._eventEmitters.push({
          event,
          callback
        });
      }
      trigger(event) {
        let eventEmitters = [];
        if (event) {
          eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
        }
        eventEmitters.forEach((eventEmitter) => {
          eventEmitter.callback();
        });
      }
    };
    network_default = NetworkMonitor;
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
    };
  }
});

// node_modules/@walletconnect/socket-transport/dist/esm/index.js
function getWebSocketUrl(_url, protocol, version) {
  var _a, _b;
  const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url.split("?");
  const params = isBrowser() ? {
    protocol,
    version,
    env: "browser",
    host: ((_a = getLocation2()) === null || _a === void 0 ? void 0 : _a.host) || ""
  } : {
    protocol,
    version,
    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
  };
  const queryString = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString;
}
var WS, SocketTransport, esm_default;
var init_esm7 = __esm({
  "node_modules/@walletconnect/socket-transport/dist/esm/index.js"() {
    init_esm6();
    init_network();
    WS = typeof global.WebSocket !== "undefined" ? global.WebSocket : require_browser();
    SocketTransport = class {
      constructor(opts) {
        this.opts = opts;
        this._queue = [];
        this._events = [];
        this._subscriptions = [];
        this._protocol = opts.protocol;
        this._version = opts.version;
        this._url = "";
        this._netMonitor = null;
        this._socket = null;
        this._nextSocket = null;
        this._subscriptions = opts.subscriptions || [];
        this._netMonitor = opts.netMonitor || new network_default();
        if (!opts.url || typeof opts.url !== "string") {
          throw new Error("Missing or invalid WebSocket url");
        }
        this._url = opts.url;
        this._netMonitor.on("online", () => this._socketCreate());
      }
      set readyState(value) {
      }
      get readyState() {
        return this._socket ? this._socket.readyState : -1;
      }
      set connecting(value) {
      }
      get connecting() {
        return this.readyState === 0;
      }
      set connected(value) {
      }
      get connected() {
        return this.readyState === 1;
      }
      set closing(value) {
      }
      get closing() {
        return this.readyState === 2;
      }
      set closed(value) {
      }
      get closed() {
        return this.readyState === 3;
      }
      open() {
        this._socketCreate();
      }
      close() {
        this._socketClose();
      }
      send(message, topic, silent) {
        if (!topic || typeof topic !== "string") {
          throw new Error("Missing or invalid topic field");
        }
        this._socketSend({
          topic,
          type: "pub",
          payload: message,
          silent: !!silent
        });
      }
      subscribe(topic) {
        this._socketSend({
          topic,
          type: "sub",
          payload: "",
          silent: true
        });
      }
      on(event, callback) {
        this._events.push({ event, callback });
      }
      _socketCreate() {
        if (this._nextSocket) {
          return;
        }
        const url = getWebSocketUrl(this._url, this._protocol, this._version);
        this._nextSocket = new WS(url);
        if (!this._nextSocket) {
          throw new Error("Failed to create socket");
        }
        this._nextSocket.onmessage = (event) => this._socketReceive(event);
        this._nextSocket.onopen = () => this._socketOpen();
        this._nextSocket.onerror = (event) => this._socketError(event);
        this._nextSocket.onclose = () => {
          setTimeout(() => {
            this._nextSocket = null;
            this._socketCreate();
          }, 1e3);
        };
      }
      _socketOpen() {
        this._socketClose();
        this._socket = this._nextSocket;
        this._nextSocket = null;
        this._queueSubscriptions();
        this._pushQueue();
      }
      _socketClose() {
        if (this._socket) {
          this._socket.onclose = () => {
          };
          this._socket.close();
        }
      }
      _socketSend(socketMessage) {
        const message = JSON.stringify(socketMessage);
        if (this._socket && this._socket.readyState === 1) {
          this._socket.send(message);
        } else {
          this._setToQueue(socketMessage);
          this._socketCreate();
        }
      }
      async _socketReceive(event) {
        let socketMessage;
        try {
          socketMessage = JSON.parse(event.data);
        } catch (error) {
          return;
        }
        this._socketSend({
          topic: socketMessage.topic,
          type: "ack",
          payload: "",
          silent: true
        });
        if (this._socket && this._socket.readyState === 1) {
          const events = this._events.filter((event2) => event2.event === "message");
          if (events && events.length) {
            events.forEach((event2) => event2.callback(socketMessage));
          }
        }
      }
      _socketError(e) {
        const events = this._events.filter((event) => event.event === "error");
        if (events && events.length) {
          events.forEach((event) => event.callback(e));
        }
      }
      _queueSubscriptions() {
        const subscriptions = this._subscriptions;
        subscriptions.forEach((topic) => this._queue.push({
          topic,
          type: "sub",
          payload: "",
          silent: true
        }));
        this._subscriptions = this.opts.subscriptions || [];
      }
      _setToQueue(socketMessage) {
        this._queue.push(socketMessage);
      }
      _pushQueue() {
        const queue = this._queue;
        queue.forEach((socketMessage) => this._socketSend(socketMessage));
        this._queue = [];
      }
    };
    esm_default = SocketTransport;
  }
});

// node_modules/@walletconnect/core/dist/esm/errors.js
var ERROR_SESSION_CONNECTED, ERROR_SESSION_DISCONNECTED, ERROR_SESSION_REJECTED, ERROR_MISSING_JSON_RPC, ERROR_MISSING_RESULT, ERROR_MISSING_ERROR, ERROR_MISSING_METHOD, ERROR_MISSING_ID, ERROR_MISSING_REQUIRED, ERROR_INVALID_RESPONSE, ERROR_INVALID_URI, ERROR_QRCODE_MODAL_NOT_PROVIDED, ERROR_QRCODE_MODAL_USER_CLOSED;
var init_errors = __esm({
  "node_modules/@walletconnect/core/dist/esm/errors.js"() {
    ERROR_SESSION_CONNECTED = "Session currently connected";
    ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
    ERROR_SESSION_REJECTED = "Session Rejected";
    ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
    ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
    ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
    ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
    ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
    ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
    ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
    ERROR_INVALID_URI = "URI format is invalid";
    ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
    ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";
  }
});

// node_modules/@walletconnect/core/dist/esm/events.js
var EventManager, events_default;
var init_events = __esm({
  "node_modules/@walletconnect/core/dist/esm/events.js"() {
    init_esm6();
    EventManager = class {
      constructor() {
        this._eventEmitters = [];
      }
      subscribe(eventEmitter) {
        this._eventEmitters.push(eventEmitter);
      }
      unsubscribe(event) {
        this._eventEmitters = this._eventEmitters.filter((x) => x.event !== event);
      }
      trigger(payload) {
        let eventEmitters = [];
        let event;
        if (isJsonRpcRequest2(payload)) {
          event = payload.method;
        } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
          event = `response:${payload.id}`;
        } else if (isInternalEvent(payload)) {
          event = payload.event;
        } else {
          event = "";
        }
        if (event) {
          eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
        }
        if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
          eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
        }
        eventEmitters.forEach((eventEmitter) => {
          if (isJsonRpcResponseError(payload)) {
            const error = new Error(payload.error.message);
            eventEmitter.callback(error, null);
          } else {
            eventEmitter.callback(null, payload);
          }
        });
      }
    };
    events_default = EventManager;
  }
});

// node_modules/@walletconnect/core/dist/esm/storage.js
var SessionStorage, storage_default;
var init_storage = __esm({
  "node_modules/@walletconnect/core/dist/esm/storage.js"() {
    init_esm6();
    SessionStorage = class {
      constructor(storageId = "walletconnect") {
        this.storageId = storageId;
      }
      getSession() {
        let session = null;
        const json = getLocal(this.storageId);
        if (json && isWalletConnectSession(json)) {
          session = json;
        }
        return session;
      }
      setSession(session) {
        setLocal(this.storageId, session);
        return session;
      }
      removeSession() {
        removeLocal(this.storageId);
      }
    };
    storage_default = SessionStorage;
  }
});

// node_modules/@walletconnect/core/dist/esm/url.js
function extractHostname(url) {
  let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
  hostname = hostname.split(":")[0];
  hostname = hostname.split("?")[0];
  return hostname;
}
function extractRootDomain(url) {
  return extractHostname(url).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url) {
  return extractRootDomain(url) === domain;
}
function getBridgeUrl(url) {
  if (shouldSelectRandomly(url)) {
    return selectRandomBridgeUrl();
  }
  return url;
}
var domain, alphanumerical, bridges;
var init_url3 = __esm({
  "node_modules/@walletconnect/core/dist/esm/url.js"() {
    domain = "walletconnect.org";
    alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
    bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
  }
});

// node_modules/@walletconnect/core/dist/esm/index.js
var Connector, esm_default2;
var init_esm8 = __esm({
  "node_modules/@walletconnect/core/dist/esm/index.js"() {
    init_esm6();
    init_esm7();
    init_errors();
    init_events();
    init_storage();
    init_url3();
    Connector = class {
      constructor(opts) {
        this.protocol = "wc";
        this.version = 1;
        this._bridge = "";
        this._key = null;
        this._clientId = "";
        this._clientMeta = null;
        this._peerId = "";
        this._peerMeta = null;
        this._handshakeId = 0;
        this._handshakeTopic = "";
        this._connected = false;
        this._accounts = [];
        this._chainId = 0;
        this._networkId = 0;
        this._rpcUrl = "";
        this._eventManager = new events_default();
        this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
        this._cryptoLib = opts.cryptoLib;
        this._sessionStorage = opts.sessionStorage || new storage_default(opts.connectorOpts.storageId);
        this._qrcodeModal = opts.connectorOpts.qrcodeModal;
        this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
        this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
        if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
          throw new Error(ERROR_MISSING_REQUIRED);
        }
        if (opts.connectorOpts.bridge) {
          this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
        }
        if (opts.connectorOpts.uri) {
          this.uri = opts.connectorOpts.uri;
        }
        const session = opts.connectorOpts.session || this._getStorageSession();
        if (session) {
          this.session = session;
        }
        if (this.handshakeId) {
          this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
        }
        this._transport = opts.transport || new esm_default({
          protocol: this.protocol,
          version: this.version,
          url: this.bridge,
          subscriptions: [this.clientId]
        });
        this._subscribeToInternalEvents();
        this._initTransport();
        if (opts.connectorOpts.uri) {
          this._subscribeToSessionRequest();
        }
        if (opts.pushServerOpts) {
          this._registerPushServer(opts.pushServerOpts);
        }
      }
      set bridge(value) {
        if (!value) {
          return;
        }
        this._bridge = value;
      }
      get bridge() {
        return this._bridge;
      }
      set key(value) {
        if (!value) {
          return;
        }
        const key = convertHexToArrayBuffer(value);
        this._key = key;
      }
      get key() {
        if (this._key) {
          const key = convertArrayBufferToHex(this._key, true);
          return key;
        }
        return "";
      }
      set clientId(value) {
        if (!value) {
          return;
        }
        this._clientId = value;
      }
      get clientId() {
        let clientId = this._clientId;
        if (!clientId) {
          clientId = this._clientId = uuid();
        }
        return this._clientId;
      }
      set peerId(value) {
        if (!value) {
          return;
        }
        this._peerId = value;
      }
      get peerId() {
        return this._peerId;
      }
      set clientMeta(value) {
      }
      get clientMeta() {
        let clientMeta = this._clientMeta;
        if (!clientMeta) {
          clientMeta = this._clientMeta = getClientMeta();
        }
        return clientMeta;
      }
      set peerMeta(value) {
        this._peerMeta = value;
      }
      get peerMeta() {
        const peerMeta = this._peerMeta;
        return peerMeta;
      }
      set handshakeTopic(value) {
        if (!value) {
          return;
        }
        this._handshakeTopic = value;
      }
      get handshakeTopic() {
        return this._handshakeTopic;
      }
      set handshakeId(value) {
        if (!value) {
          return;
        }
        this._handshakeId = value;
      }
      get handshakeId() {
        return this._handshakeId;
      }
      get uri() {
        const _uri = this._formatUri();
        return _uri;
      }
      set uri(value) {
        if (!value) {
          return;
        }
        const { handshakeTopic, bridge, key } = this._parseUri(value);
        this.handshakeTopic = handshakeTopic;
        this.bridge = bridge;
        this.key = key;
      }
      set chainId(value) {
        this._chainId = value;
      }
      get chainId() {
        const chainId = this._chainId;
        return chainId;
      }
      set networkId(value) {
        this._networkId = value;
      }
      get networkId() {
        const networkId = this._networkId;
        return networkId;
      }
      set accounts(value) {
        this._accounts = value;
      }
      get accounts() {
        const accounts = this._accounts;
        return accounts;
      }
      set rpcUrl(value) {
        this._rpcUrl = value;
      }
      get rpcUrl() {
        const rpcUrl = this._rpcUrl;
        return rpcUrl;
      }
      set connected(value) {
      }
      get connected() {
        return this._connected;
      }
      set pending(value) {
      }
      get pending() {
        return !!this._handshakeTopic;
      }
      get session() {
        return {
          connected: this.connected,
          accounts: this.accounts,
          chainId: this.chainId,
          bridge: this.bridge,
          key: this.key,
          clientId: this.clientId,
          clientMeta: this.clientMeta,
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          handshakeId: this.handshakeId,
          handshakeTopic: this.handshakeTopic
        };
      }
      set session(value) {
        if (!value) {
          return;
        }
        this._connected = value.connected;
        this.accounts = value.accounts;
        this.chainId = value.chainId;
        this.bridge = value.bridge;
        this.key = value.key;
        this.clientId = value.clientId;
        this.clientMeta = value.clientMeta;
        this.peerId = value.peerId;
        this.peerMeta = value.peerMeta;
        this.handshakeId = value.handshakeId;
        this.handshakeTopic = value.handshakeTopic;
      }
      on(event, callback) {
        const eventEmitter = {
          event,
          callback
        };
        this._eventManager.subscribe(eventEmitter);
      }
      off(event) {
        this._eventManager.unsubscribe(event);
      }
      async createInstantRequest(instantRequest) {
        this._key = await this._generateKey();
        const request = this._formatRequest({
          method: "wc_instantRequest",
          params: [
            {
              peerId: this.clientId,
              peerMeta: this.clientMeta,
              request: this._formatRequest(instantRequest)
            }
          ]
        });
        this.handshakeId = request.id;
        this.handshakeTopic = uuid();
        this._eventManager.trigger({
          event: "display_uri",
          params: [this.uri]
        });
        this.on("modal_closed", () => {
          throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
        });
        const endInstantRequest = () => {
          this.killSession();
        };
        try {
          const result = await this._sendCallRequest(request);
          if (result) {
            endInstantRequest();
          }
          return result;
        } catch (error) {
          endInstantRequest();
          throw error;
        }
      }
      async connect(opts) {
        if (!this._qrcodeModal) {
          throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
        }
        if (this.connected) {
          return {
            chainId: this.chainId,
            accounts: this.accounts
          };
        }
        await this.createSession(opts);
        return new Promise(async (resolve, reject) => {
          this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
          this.on("connect", (error, payload) => {
            if (error) {
              return reject(error);
            }
            resolve(payload.params[0]);
          });
        });
      }
      async createSession(opts) {
        if (this._connected) {
          throw new Error(ERROR_SESSION_CONNECTED);
        }
        if (this.pending) {
          return;
        }
        this._key = await this._generateKey();
        const request = this._formatRequest({
          method: "wc_sessionRequest",
          params: [
            {
              peerId: this.clientId,
              peerMeta: this.clientMeta,
              chainId: opts && opts.chainId ? opts.chainId : null
            }
          ]
        });
        this.handshakeId = request.id;
        this.handshakeTopic = uuid();
        this._sendSessionRequest(request, "Session update rejected", {
          topic: this.handshakeTopic
        });
        this._eventManager.trigger({
          event: "display_uri",
          params: [this.uri]
        });
      }
      approveSession(sessionStatus) {
        if (this._connected) {
          throw new Error(ERROR_SESSION_CONNECTED);
        }
        this.chainId = sessionStatus.chainId;
        this.accounts = sessionStatus.accounts;
        this.networkId = sessionStatus.networkId || 0;
        this.rpcUrl = sessionStatus.rpcUrl || "";
        const sessionParams = {
          approved: true,
          chainId: this.chainId,
          networkId: this.networkId,
          accounts: this.accounts,
          rpcUrl: this.rpcUrl,
          peerId: this.clientId,
          peerMeta: this.clientMeta
        };
        const response = {
          id: this.handshakeId,
          jsonrpc: "2.0",
          result: sessionParams
        };
        this._sendResponse(response);
        this._connected = true;
        this._setStorageSession();
        this._eventManager.trigger({
          event: "connect",
          params: [
            {
              peerId: this.peerId,
              peerMeta: this.peerMeta,
              chainId: this.chainId,
              accounts: this.accounts
            }
          ]
        });
      }
      rejectSession(sessionError) {
        if (this._connected) {
          throw new Error(ERROR_SESSION_CONNECTED);
        }
        const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
        const response = this._formatResponse({
          id: this.handshakeId,
          error: { message }
        });
        this._sendResponse(response);
        this._connected = false;
        this._eventManager.trigger({
          event: "disconnect",
          params: [{ message }]
        });
        this._removeStorageSession();
      }
      updateSession(sessionStatus) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        this.chainId = sessionStatus.chainId;
        this.accounts = sessionStatus.accounts;
        this.networkId = sessionStatus.networkId || 0;
        this.rpcUrl = sessionStatus.rpcUrl || "";
        const sessionParams = {
          approved: true,
          chainId: this.chainId,
          networkId: this.networkId,
          accounts: this.accounts,
          rpcUrl: this.rpcUrl
        };
        const request = this._formatRequest({
          method: "wc_sessionUpdate",
          params: [sessionParams]
        });
        this._sendSessionRequest(request, "Session update rejected");
        this._eventManager.trigger({
          event: "session_update",
          params: [
            {
              chainId: this.chainId,
              accounts: this.accounts
            }
          ]
        });
        this._manageStorageSession();
      }
      async killSession(sessionError) {
        const message = sessionError ? sessionError.message : "Session Disconnected";
        const sessionParams = {
          approved: false,
          chainId: null,
          networkId: null,
          accounts: null
        };
        const request = this._formatRequest({
          method: "wc_sessionUpdate",
          params: [sessionParams]
        });
        await this._sendRequest(request);
        this._handleSessionDisconnect(message);
      }
      async sendTransaction(tx) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const parsedTx = parseTransactionData(tx);
        const request = this._formatRequest({
          method: "eth_sendTransaction",
          params: [parsedTx]
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async signTransaction(tx) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const parsedTx = parseTransactionData(tx);
        const request = this._formatRequest({
          method: "eth_signTransaction",
          params: [parsedTx]
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async signMessage(params) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const request = this._formatRequest({
          method: "eth_sign",
          params
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async signPersonalMessage(params) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        params = parsePersonalSign(params);
        const request = this._formatRequest({
          method: "personal_sign",
          params
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async signTypedData(params) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        const request = this._formatRequest({
          method: "eth_signTypedData",
          params
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      async updateChain(chainParams) {
        if (!this._connected) {
          throw new Error("Session currently disconnected");
        }
        const request = this._formatRequest({
          method: "wallet_updateChain",
          params: [chainParams]
        });
        const result = await this._sendCallRequest(request);
        return result;
      }
      unsafeSend(request, options) {
        this._sendRequest(request, options);
        this._eventManager.trigger({
          event: "call_request_sent",
          params: [{ request, options }]
        });
        return new Promise((resolve, reject) => {
          this._subscribeToResponse(request.id, (error, payload) => {
            if (error) {
              reject(error);
              return;
            }
            if (!payload) {
              throw new Error(ERROR_MISSING_JSON_RPC);
            }
            resolve(payload);
          });
        });
      }
      async sendCustomRequest(request, options) {
        if (!this._connected) {
          throw new Error(ERROR_SESSION_DISCONNECTED);
        }
        switch (request.method) {
          case "eth_accounts":
            return this.accounts;
          case "eth_chainId":
            return convertNumberToHex(this.chainId);
          case "eth_sendTransaction":
          case "eth_signTransaction":
            if (request.params) {
              request.params[0] = parseTransactionData(request.params[0]);
            }
            break;
          case "personal_sign":
            if (request.params) {
              request.params = parsePersonalSign(request.params);
            }
            break;
          default:
            break;
        }
        const formattedRequest = this._formatRequest(request);
        const result = await this._sendCallRequest(formattedRequest, options);
        return result;
      }
      approveRequest(response) {
        if (isJsonRpcResponseSuccess(response)) {
          const formattedResponse = this._formatResponse(response);
          this._sendResponse(formattedResponse);
        } else {
          throw new Error(ERROR_MISSING_RESULT);
        }
      }
      rejectRequest(response) {
        if (isJsonRpcResponseError(response)) {
          const formattedResponse = this._formatResponse(response);
          this._sendResponse(formattedResponse);
        } else {
          throw new Error(ERROR_MISSING_ERROR);
        }
      }
      transportClose() {
        this._transport.close();
      }
      async _sendRequest(request, options) {
        const callRequest = this._formatRequest(request);
        const encryptionPayload = await this._encrypt(callRequest);
        const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
        const payload = JSON.stringify(encryptionPayload);
        const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
        this._transport.send(payload, topic, silent);
      }
      async _sendResponse(response) {
        const encryptionPayload = await this._encrypt(response);
        const topic = this.peerId;
        const payload = JSON.stringify(encryptionPayload);
        const silent = true;
        this._transport.send(payload, topic, silent);
      }
      async _sendSessionRequest(request, errorMsg, options) {
        this._sendRequest(request, options);
        this._subscribeToSessionResponse(request.id, errorMsg);
      }
      _sendCallRequest(request, options) {
        this._sendRequest(request, options);
        this._eventManager.trigger({
          event: "call_request_sent",
          params: [{ request, options }]
        });
        return this._subscribeToCallResponse(request.id);
      }
      _formatRequest(request) {
        if (typeof request.method === "undefined") {
          throw new Error(ERROR_MISSING_METHOD);
        }
        const formattedRequest = {
          id: typeof request.id === "undefined" ? payloadId2() : request.id,
          jsonrpc: "2.0",
          method: request.method,
          params: typeof request.params === "undefined" ? [] : request.params
        };
        return formattedRequest;
      }
      _formatResponse(response) {
        if (typeof response.id === "undefined") {
          throw new Error(ERROR_MISSING_ID);
        }
        const baseResponse = { id: response.id, jsonrpc: "2.0" };
        if (isJsonRpcResponseError(response)) {
          const error = formatRpcError(response.error);
          const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
          return errorResponse;
        } else if (isJsonRpcResponseSuccess(response)) {
          const successResponse = Object.assign(Object.assign({}, baseResponse), response);
          return successResponse;
        }
        throw new Error(ERROR_INVALID_RESPONSE);
      }
      _handleSessionDisconnect(errorMsg) {
        const message = errorMsg || "Session Disconnected";
        if (!this._connected) {
          if (this._qrcodeModal) {
            this._qrcodeModal.close();
          }
          removeLocal(mobileLinkChoiceKey);
        }
        if (this._connected) {
          this._connected = false;
        }
        if (this._handshakeId) {
          this._handshakeId = 0;
        }
        if (this._handshakeTopic) {
          this._handshakeTopic = "";
        }
        if (this._peerId) {
          this._peerId = "";
        }
        this._eventManager.trigger({
          event: "disconnect",
          params: [{ message }]
        });
        this._removeStorageSession();
        this.transportClose();
      }
      _handleSessionResponse(errorMsg, sessionParams) {
        if (sessionParams) {
          if (sessionParams.approved) {
            if (!this._connected) {
              this._connected = true;
              if (sessionParams.chainId) {
                this.chainId = sessionParams.chainId;
              }
              if (sessionParams.accounts) {
                this.accounts = sessionParams.accounts;
              }
              if (sessionParams.peerId && !this.peerId) {
                this.peerId = sessionParams.peerId;
              }
              if (sessionParams.peerMeta && !this.peerMeta) {
                this.peerMeta = sessionParams.peerMeta;
              }
              this._eventManager.trigger({
                event: "connect",
                params: [
                  {
                    peerId: this.peerId,
                    peerMeta: this.peerMeta,
                    chainId: this.chainId,
                    accounts: this.accounts
                  }
                ]
              });
            } else {
              if (sessionParams.chainId) {
                this.chainId = sessionParams.chainId;
              }
              if (sessionParams.accounts) {
                this.accounts = sessionParams.accounts;
              }
              this._eventManager.trigger({
                event: "session_update",
                params: [
                  {
                    chainId: this.chainId,
                    accounts: this.accounts
                  }
                ]
              });
            }
            this._manageStorageSession();
          } else {
            this._handleSessionDisconnect(errorMsg);
          }
        } else {
          this._handleSessionDisconnect(errorMsg);
        }
      }
      async _handleIncomingMessages(socketMessage) {
        const activeTopics = [this.clientId, this.handshakeTopic];
        if (!activeTopics.includes(socketMessage.topic)) {
          return;
        }
        let encryptionPayload;
        try {
          encryptionPayload = JSON.parse(socketMessage.payload);
        } catch (error) {
          return;
        }
        const payload = await this._decrypt(encryptionPayload);
        if (payload) {
          this._eventManager.trigger(payload);
        }
      }
      _subscribeToSessionRequest() {
        this._transport.subscribe(this.handshakeTopic);
      }
      _subscribeToResponse(id, callback) {
        this.on(`response:${id}`, callback);
      }
      _subscribeToSessionResponse(id, errorMsg) {
        this._subscribeToResponse(id, (error, payload) => {
          if (error) {
            this._handleSessionResponse(error.message);
            return;
          }
          if (isJsonRpcResponseSuccess(payload)) {
            this._handleSessionResponse(errorMsg, payload.result);
          } else if (payload.error && payload.error.message) {
            this._handleSessionResponse(payload.error.message);
          } else {
            this._handleSessionResponse(errorMsg);
          }
        });
      }
      _subscribeToCallResponse(id) {
        return new Promise((resolve, reject) => {
          this._subscribeToResponse(id, (error, payload) => {
            if (error) {
              reject(error);
              return;
            }
            if (isJsonRpcResponseSuccess(payload)) {
              resolve(payload.result);
            } else if (payload.error && payload.error.message) {
              reject(new Error(payload.error.message));
            } else {
              reject(new Error(ERROR_INVALID_RESPONSE));
            }
          });
        });
      }
      _subscribeToInternalEvents() {
        this.on("display_uri", () => {
          if (this._qrcodeModal) {
            this._qrcodeModal.open(this.uri, () => {
              this._eventManager.trigger({
                event: "modal_closed",
                params: []
              });
            }, this._qrcodeModalOptions);
          }
        });
        this.on("connect", () => {
          if (this._qrcodeModal) {
            this._qrcodeModal.close();
          }
        });
        this.on("call_request_sent", (error, payload) => {
          const { request } = payload.params[0];
          if (isMobile() && this._signingMethods.includes(request.method)) {
            const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
            if (mobileLinkUrl) {
              window.location.href = mobileLinkUrl.href;
            }
          }
        });
        this.on("wc_sessionRequest", (error, payload) => {
          if (error) {
            this._eventManager.trigger({
              event: "error",
              params: [
                {
                  code: "SESSION_REQUEST_ERROR",
                  message: error.toString()
                }
              ]
            });
          }
          this.handshakeId = payload.id;
          this.peerId = payload.params[0].peerId;
          this.peerMeta = payload.params[0].peerMeta;
          const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
          this._eventManager.trigger(internalPayload);
        });
        this.on("wc_sessionUpdate", (error, payload) => {
          if (error) {
            this._handleSessionResponse(error.message);
          }
          this._handleSessionResponse("Session disconnected", payload.params[0]);
        });
      }
      _initTransport() {
        this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
        this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
        this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
        this._transport.on("error", () => this._eventManager.trigger({
          event: "transport_error",
          params: ["Websocket connection failed"]
        }));
        this._transport.open();
      }
      _formatUri() {
        const protocol = this.protocol;
        const handshakeTopic = this.handshakeTopic;
        const version = this.version;
        const bridge = encodeURIComponent(this.bridge);
        const key = this.key;
        const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;
        return uri;
      }
      _parseUri(uri) {
        const result = parseWalletConnectUri(uri);
        if (result.protocol === this.protocol) {
          if (!result.handshakeTopic) {
            throw Error("Invalid or missing handshakeTopic parameter value");
          }
          const handshakeTopic = result.handshakeTopic;
          if (!result.bridge) {
            throw Error("Invalid or missing bridge url parameter value");
          }
          const bridge = decodeURIComponent(result.bridge);
          if (!result.key) {
            throw Error("Invalid or missing key parameter value");
          }
          const key = result.key;
          return { handshakeTopic, bridge, key };
        } else {
          throw new Error(ERROR_INVALID_URI);
        }
      }
      async _generateKey() {
        if (this._cryptoLib) {
          const result = await this._cryptoLib.generateKey();
          return result;
        }
        return null;
      }
      async _encrypt(data) {
        const key = this._key;
        if (this._cryptoLib && key) {
          const result = await this._cryptoLib.encrypt(data, key);
          return result;
        }
        return null;
      }
      async _decrypt(payload) {
        const key = this._key;
        if (this._cryptoLib && key) {
          const result = await this._cryptoLib.decrypt(payload, key);
          return result;
        }
        return null;
      }
      _getStorageSession() {
        let result = null;
        if (this._sessionStorage) {
          result = this._sessionStorage.getSession();
        }
        return result;
      }
      _setStorageSession() {
        if (this._sessionStorage) {
          this._sessionStorage.setSession(this.session);
        }
      }
      _removeStorageSession() {
        if (this._sessionStorage) {
          this._sessionStorage.removeSession();
        }
      }
      _manageStorageSession() {
        if (this._connected) {
          this._setStorageSession();
        } else {
          this._removeStorageSession();
        }
      }
      _registerPushServer(pushServerOpts) {
        if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
          throw Error("Invalid or missing pushServerOpts.url parameter value");
        }
        if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
          throw Error("Invalid or missing pushServerOpts.type parameter value");
        }
        if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
          throw Error("Invalid or missing pushServerOpts.token parameter value");
        }
        const pushSubscription = {
          bridge: this.bridge,
          topic: this.clientId,
          type: pushServerOpts.type,
          token: pushServerOpts.token,
          peerName: "",
          language: pushServerOpts.language || ""
        };
        this.on("connect", async (error, payload) => {
          if (error) {
            throw error;
          }
          if (pushServerOpts.peerMeta) {
            const peerName = payload.params[0].peerMeta.name;
            pushSubscription.peerName = peerName;
          }
          try {
            const response = await fetch(`${pushServerOpts.url}/new`, {
              method: "POST",
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json"
              },
              body: JSON.stringify(pushSubscription)
            });
            const json = await response.json();
            if (!json.success) {
              throw Error("Failed to register in Push Server");
            }
          } catch (error2) {
            throw Error("Failed to register in Push Server");
          }
        });
      }
    };
    esm_default2 = Connector;
  }
});

// node_modules/@walletconnect/randombytes/dist/esm/browser/index.js
function randomBytes(length) {
  const browserCrypto = env.getBrowerCrypto();
  return browserCrypto.getRandomValues(new Uint8Array(length));
}
var env;
var init_browser2 = __esm({
  "node_modules/@walletconnect/randombytes/dist/esm/browser/index.js"() {
    env = __toESM(require_cjs3());
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/length.js
var LENGTH_0, LENGTH_1, LENGTH_16, LENGTH_32, LENGTH_64, LENGTH_128, LENGTH_256, LENGTH_512, LENGTH_1024;
var init_length = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/length.js"() {
    LENGTH_0 = 0;
    LENGTH_1 = 1;
    LENGTH_16 = 16;
    LENGTH_32 = 32;
    LENGTH_64 = 64;
    LENGTH_128 = 128;
    LENGTH_256 = 256;
    LENGTH_512 = 512;
    LENGTH_1024 = 1024;
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/default.js
var AES_LENGTH, HMAC_LENGTH, AES_BROWSER_ALGO, HMAC_BROWSER_ALGO, HMAC_BROWSER, SHA256_BROWSER_ALGO, SHA512_BROWSER_ALGO, AES_NODE_ALGO, HMAC_NODE_ALGO, SHA256_NODE_ALGO, SHA512_NODE_ALGO, RIPEMD160_NODE_ALGO, PREFIX_LENGTH, KEY_LENGTH, IV_LENGTH, MAC_LENGTH;
var init_default = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/default.js"() {
    init_length();
    AES_LENGTH = LENGTH_256;
    HMAC_LENGTH = LENGTH_256;
    AES_BROWSER_ALGO = "AES-CBC";
    HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
    HMAC_BROWSER = "HMAC";
    SHA256_BROWSER_ALGO = "SHA-256";
    SHA512_BROWSER_ALGO = "SHA-512";
    AES_NODE_ALGO = `aes-${AES_LENGTH}-cbc`;
    HMAC_NODE_ALGO = `sha${HMAC_LENGTH}`;
    SHA256_NODE_ALGO = "sha256";
    SHA512_NODE_ALGO = "sha512";
    RIPEMD160_NODE_ALGO = "ripemd160";
    PREFIX_LENGTH = LENGTH_1;
    KEY_LENGTH = LENGTH_32;
    IV_LENGTH = LENGTH_16;
    MAC_LENGTH = LENGTH_32;
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js
var HEX_ENC, UTF8_ENC;
var init_encoding2 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js"() {
    HEX_ENC = "hex";
    UTF8_ENC = "utf8";
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/error.js
var ERROR_BAD_MAC;
var init_error2 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/error.js"() {
    ERROR_BAD_MAC = "Bad MAC";
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/operations.js
var ENCRYPT_OP, DECRYPT_OP, SIGN_OP, VERIFY_OP;
var init_operations = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/operations.js"() {
    ENCRYPT_OP = "encrypt";
    DECRYPT_OP = "decrypt";
    SIGN_OP = "sign";
    VERIFY_OP = "verify";
  }
});

// node_modules/@walletconnect/crypto/dist/esm/constants/index.js
var init_constants3 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/constants/index.js"() {
    init_default();
    init_encoding2();
    init_error2();
    init_length();
    init_operations();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
function getAlgo(type) {
  return type === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
    hash: { name: HMAC_BROWSER_ALGO },
    name: HMAC_BROWSER
  };
}
function getOps(type) {
  return type === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
}
async function browserImportKey(buffer, type = AES_BROWSER_ALGO) {
  return env2.getSubtleCrypto().importKey("raw", buffer, getAlgo(type), true, getOps(type));
}
async function browserAesEncrypt(iv, key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.encrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserAesDecrypt(iv, key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.decrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserHmacSha256Sign(key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: HMAC_LENGTH,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature);
}
async function browserHmacSha512Sign(key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: LENGTH_512,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature);
}
async function browserSha256(data) {
  const subtle = env2.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA256_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}
async function browserSha512(data) {
  const subtle = env2.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA512_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}
var env2;
var init_browser3 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/lib/browser.js"() {
    env2 = __toESM(require_cjs3());
    init_constants3();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/browser/aes.js
function aesCbcEncrypt(iv, key, data) {
  return browserAesEncrypt(iv, key, data);
}
function aesCbcDecrypt(iv, key, data) {
  return browserAesDecrypt(iv, key, data);
}
var init_aes = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/browser/aes.js"() {
    init_browser3();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/env.js
var env_exports2 = {};
var init_env2 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/env.js"() {
    __reExport(env_exports2, __toESM(require_cjs3()));
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js
var PADDING, pkcs7;
var init_pkcs7 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js"() {
    PADDING = [
      [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16],
      [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
      [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
      [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
      [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
      [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
      [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
      [9, 9, 9, 9, 9, 9, 9, 9, 9],
      [8, 8, 8, 8, 8, 8, 8, 8],
      [7, 7, 7, 7, 7, 7, 7],
      [6, 6, 6, 6, 6, 6],
      [5, 5, 5, 5, 5],
      [4, 4, 4, 4],
      [3, 3, 3],
      [2, 2],
      [1]
    ];
    pkcs7 = {
      pad(plaintext) {
        const padding = PADDING[plaintext.byteLength % 16 || 0];
        const result = new Uint8Array(plaintext.byteLength + padding.length);
        result.set(plaintext);
        result.set(padding, plaintext.byteLength);
        return result;
      },
      unpad(padded) {
        return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
      }
    };
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/types.js
var init_types2 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/types.js"() {
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function isConstantTime(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  let res = 0;
  for (let i = 0; i < arr1.length; i++) {
    res |= arr1[i] ^ arr2[i];
  }
  return res === 0;
}
var init_validators3 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js"() {
  }
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
var helpers_exports = {};
__export(helpers_exports, {
  assert: () => assert,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7
});
var init_helpers = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/helpers/index.js"() {
    init_env2();
    __reExport(helpers_exports, env_exports2);
    init_pkcs7();
    init_types2();
    init_validators3();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js
async function hmacSha256Sign(key, msg) {
  const result = await browserHmacSha256Sign(key, msg);
  return result;
}
async function hmacSha256Verify(key, msg, sig) {
  const expectedSig = await browserHmacSha256Sign(key, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}
async function hmacSha512Sign(key, msg) {
  const result = await browserHmacSha512Sign(key, msg);
  return result;
}
async function hmacSha512Verify(key, msg, sig) {
  const expectedSig = await browserHmacSha512Sign(key, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}
var init_hmac = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js"() {
    init_browser3();
    init_helpers();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js
async function sha256(msg) {
  const result = await browserSha256(msg);
  return result;
}
async function sha512(msg) {
  const result = await browserSha512(msg);
  return result;
}
async function ripemd160(msg) {
  throw new Error("Not supported for Browser async methods, use sync instead!");
}
var init_sha2 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js"() {
    init_browser3();
  }
});

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  AES_BROWSER_ALGO: () => AES_BROWSER_ALGO,
  AES_LENGTH: () => AES_LENGTH,
  AES_NODE_ALGO: () => AES_NODE_ALGO,
  DECRYPT_OP: () => DECRYPT_OP,
  ENCRYPT_OP: () => ENCRYPT_OP,
  ERROR_BAD_MAC: () => ERROR_BAD_MAC,
  HEX_ENC: () => HEX_ENC,
  HMAC_BROWSER: () => HMAC_BROWSER,
  HMAC_BROWSER_ALGO: () => HMAC_BROWSER_ALGO,
  HMAC_LENGTH: () => HMAC_LENGTH,
  HMAC_NODE_ALGO: () => HMAC_NODE_ALGO,
  IV_LENGTH: () => IV_LENGTH,
  KEY_LENGTH: () => KEY_LENGTH,
  LENGTH_0: () => LENGTH_0,
  LENGTH_1: () => LENGTH_1,
  LENGTH_1024: () => LENGTH_1024,
  LENGTH_128: () => LENGTH_128,
  LENGTH_16: () => LENGTH_16,
  LENGTH_256: () => LENGTH_256,
  LENGTH_32: () => LENGTH_32,
  LENGTH_512: () => LENGTH_512,
  LENGTH_64: () => LENGTH_64,
  MAC_LENGTH: () => MAC_LENGTH,
  PREFIX_LENGTH: () => PREFIX_LENGTH,
  RIPEMD160_NODE_ALGO: () => RIPEMD160_NODE_ALGO,
  SHA256_BROWSER_ALGO: () => SHA256_BROWSER_ALGO,
  SHA256_NODE_ALGO: () => SHA256_NODE_ALGO,
  SHA512_BROWSER_ALGO: () => SHA512_BROWSER_ALGO,
  SHA512_NODE_ALGO: () => SHA512_NODE_ALGO,
  SIGN_OP: () => SIGN_OP,
  UTF8_ENC: () => UTF8_ENC,
  VERIFY_OP: () => VERIFY_OP,
  aesCbcDecrypt: () => aesCbcDecrypt,
  aesCbcEncrypt: () => aesCbcEncrypt,
  assert: () => assert,
  hmacSha256Sign: () => hmacSha256Sign,
  hmacSha256Verify: () => hmacSha256Verify,
  hmacSha512Sign: () => hmacSha512Sign,
  hmacSha512Verify: () => hmacSha512Verify,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7,
  randomBytes: () => randomBytes,
  ripemd160: () => ripemd160,
  sha256: () => sha256,
  sha512: () => sha512
});
var init_browser4 = __esm({
  "node_modules/@walletconnect/crypto/dist/esm/browser/index.js"() {
    init_browser2();
    init_aes();
    init_hmac();
    init_sha2();
    init_helpers();
    __reExport(browser_exports, helpers_exports);
    init_constants3();
  }
});

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  decrypt: () => decrypt,
  encrypt: () => encrypt,
  generateKey: () => generateKey,
  verifyHmac: () => verifyHmac
});
async function generateKey(length) {
  const _length = (length || 256) / 8;
  const bytes = randomBytes(_length);
  const result = convertBufferToArrayBuffer(arrayToBuffer(bytes));
  return result;
}
async function verifyHmac(payload, key) {
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const hmac = hexToArray(payload.hmac);
  const hmacHex = arrayToHex(hmac, false);
  const unsigned = concatArrays(cipherText, iv);
  const chmac = await hmacSha256Sign(key, unsigned);
  const chmacHex = arrayToHex(chmac, false);
  if (removeHexPrefix(hmacHex) === removeHexPrefix(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt(data, key, providedIv) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = arrayToHex(iv, false);
  const contentString = JSON.stringify(data);
  const content = utf8ToArray(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content);
  const cipherTextHex = arrayToHex(cipherText, false);
  const unsigned = concatArrays(cipherText, iv);
  const hmac = await hmacSha256Sign(_key, unsigned);
  const hmacHex = arrayToHex(hmac, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt(payload, key) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const buffer = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = arrayToUtf8(buffer);
  let data;
  try {
    data = JSON.parse(utf8);
  } catch (error) {
    return null;
  }
  return data;
}
var init_esm9 = __esm({
  "node_modules/@walletconnect/iso-crypto/dist/esm/index.js"() {
    init_browser4();
    init_esm3();
    init_esm6();
  }
});

// node_modules/@walletconnect/client/dist/esm/index.js
var WalletConnect, esm_default3;
var init_esm10 = __esm({
  "node_modules/@walletconnect/client/dist/esm/index.js"() {
    init_esm8();
    init_esm9();
    WalletConnect = class extends esm_default2 {
      constructor(connectorOpts, pushServerOpts) {
        super({
          cryptoLib: esm_exports5,
          connectorOpts,
          pushServerOpts
        });
      }
    };
    esm_default3 = WalletConnect;
  }
});

export {
  getFromWindow2 as getFromWindow,
  esm_exports2 as esm_exports,
  init_esm2 as init_esm,
  signingMethods,
  payloadId2 as payloadId,
  getRpcUrl,
  parsePersonalSign,
  init_esm6 as init_esm2,
  esm_default3 as esm_default,
  init_esm10 as init_esm3
};
//# sourceMappingURL=chunk-B7MHWCQD.js.map
