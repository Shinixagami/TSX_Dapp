import {
  WalletConnectProvider,
  init_ethereumProvider_esm
} from "./chunk-T7G553PU.js";
import "./chunk-JMSNP5OZ.js";
import {
  esm_default,
  init_esm3 as init_esm
} from "./chunk-B7MHWCQD.js";
import "./chunk-VG2MP6HV.js";
import "./chunk-FWQTTRC5.js";
import "./chunk-UHKGATVF.js";
import "./chunk-N4XIP4TA.js";
import "./chunk-WV6JY4FM.js";
import "./chunk-HJ4FI4XZ.js";
import {
  require_loglevel
} from "./chunk-LZLTGSPD.js";
import "./chunk-MDAVZMLP.js";
import {
  ADAPTER_CATEGORY,
  ADAPTER_EVENTS,
  ADAPTER_NAMESPACES,
  ADAPTER_STATUS,
  BaseAdapter,
  CHAIN_NAMESPACES,
  WALLET_ADAPTERS,
  WalletInitializationError,
  WalletLoginError,
  Web3AuthError,
  _defineProperty,
  getChainConfig,
  init_base_esm,
  init_defineProperty,
  isHexStrict
} from "./chunk-7JKCMCQN.js";
import {
  __esm,
  __toESM
} from "./chunk-JGDUASYK.js";

// node_modules/@web3auth/wallet-connect-v1-adapter/dist/walletConnectV1Adapter.esm.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var import_loglevel, WalletConnectV1Adapter;
var init_walletConnectV1Adapter_esm = __esm({
  "node_modules/@web3auth/wallet-connect-v1-adapter/dist/walletConnectV1Adapter.esm.js"() {
    init_defineProperty();
    init_esm();
    init_base_esm();
    init_ethereumProvider_esm();
    import_loglevel = __toESM(require_loglevel());
    WalletConnectV1Adapter = class extends BaseAdapter {
      constructor() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        super();
        _defineProperty(this, "name", WALLET_ADAPTERS.WALLET_CONNECT_V1);
        _defineProperty(this, "adapterNamespace", ADAPTER_NAMESPACES.EIP155);
        _defineProperty(this, "currentChainNamespace", CHAIN_NAMESPACES.EIP155);
        _defineProperty(this, "type", ADAPTER_CATEGORY.EXTERNAL);
        _defineProperty(this, "adapterOptions", void 0);
        _defineProperty(this, "status", ADAPTER_STATUS.NOT_READY);
        _defineProperty(this, "adapterData", {
          uri: ""
        });
        _defineProperty(this, "connector", null);
        _defineProperty(this, "wcProvider", null);
        _defineProperty(this, "rehydrated", false);
        this.adapterOptions = _objectSpread({}, options);
        this.chainConfig = options.chainConfig || null;
      }
      get connected() {
        var _this$connector;
        return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);
      }
      get provider() {
        var _this$wcProvider;
        return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;
      }
      set provider(_) {
        throw new Error("Not implemented");
      }
      async init() {
        super.checkInitializationRequirements();
        if (!this.chainConfig) {
          this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);
        }
        this.connector = this.getWalletConnectInstance();
        this.wcProvider = new WalletConnectProvider({
          config: {
            chainConfig: this.chainConfig
          }
        });
        this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);
        this.status = ADAPTER_STATUS.READY;
        if (this.connector.connected) {
          this.rehydrated = true;
          await this.onConnectHandler({
            accounts: this.connector.accounts,
            chainId: this.connector.chainId.toString()
          });
        }
      }
      async connect() {
        super.checkConnectionRequirements();
        if (!this.connector)
          throw WalletInitializationError.notReady("Wallet adapter is not ready yet");
        if (this.connected) {
          await this.onConnectHandler({
            accounts: this.connector.accounts,
            chainId: this.connector.chainId.toString()
          });
          return this.provider;
        }
        if (this.status !== ADAPTER_STATUS.CONNECTING) {
          var _this$adapterOptions$;
          if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {
            this.connector = this.getWalletConnectInstance();
          }
          await this.createNewSession();
          this.status = ADAPTER_STATUS.CONNECTING;
          this.emit(ADAPTER_EVENTS.CONNECTING, {
            adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1
          });
        }
        return new Promise((resolve, reject) => {
          if (!this.connector)
            return reject(WalletInitializationError.notReady("Wallet adapter is not ready yet"));
          this.connector.on("modal_closed", async () => {
            this.status = ADAPTER_STATUS.READY;
            this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);
            return reject(new Error("User closed modal"));
          });
          try {
            this.connector.on("connect", async (error, payload) => {
              if (error) {
                this.emit(ADAPTER_EVENTS.ERRORED, error);
              }
              await this.onConnectHandler(payload.params[0]);
              return resolve(this.provider);
            });
          } catch (error) {
            import_loglevel.default.error("Wallet connect v1 adapter error while connecting", error);
            this.status = ADAPTER_STATUS.READY;
            this.rehydrated = true;
            this.emit(ADAPTER_EVENTS.ERRORED, error);
            reject(error instanceof Web3AuthError ? error : WalletLoginError.connectionError("Failed to login with wallet connect: ".concat((error === null || error === void 0 ? void 0 : error.message) || "")));
          }
        });
      }
      async getUserInfo() {
        if (!this.connected)
          throw WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
        return {};
      }
      async disconnect() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          cleanup: false
        };
        const {
          cleanup
        } = options;
        if (!this.connector || !this.connected)
          throw WalletLoginError.notConnectedError("Not connected with wallet");
        await this.connector.killSession();
        this.rehydrated = false;
        if (cleanup) {
          this.connector = null;
          this.status = ADAPTER_STATUS.NOT_READY;
          this.wcProvider = null;
        } else {
          this.status = ADAPTER_STATUS.READY;
        }
        this.emit(ADAPTER_EVENTS.DISCONNECTED);
      }
      async createNewSession() {
        var _this$adapterOptions, _this$adapterOptions$2;
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          forceNewSession: false
        };
        if (!this.connector)
          throw WalletInitializationError.notReady("Wallet adapter is not ready yet");
        if (opts.forceNewSession && this.connector.pending) {
          await this.connector.killSession();
        }
        if ((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$2 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$2 !== void 0 && _this$adapterOptions$2.qrcodeModal) {
          var _this$chainConfig;
          await this.connector.createSession({
            chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || "0x1", 16)
          });
          return;
        }
        return new Promise((resolve, reject) => {
          var _this$chainConfig2;
          if (!this.connector)
            return reject(WalletInitializationError.notReady("Wallet adapter is not ready yet"));
          import_loglevel.default.debug("creating new session for web3auth wallet connect");
          this.connector.on("display_uri", async (err, payload) => {
            var _this$connector2;
            if (err) {
              this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.connectionError("Failed to display wallet connect qr code"));
              return reject(err);
            }
            const uri = payload.params[0];
            this.updateAdapterData({
              uri
            });
            (_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.off("display_uri");
            return resolve();
          });
          this.connector.createSession({
            chainId: parseInt(((_this$chainConfig2 = this.chainConfig) === null || _this$chainConfig2 === void 0 ? void 0 : _this$chainConfig2.chainId) || "0x1", 16)
          }).catch((error) => {
            import_loglevel.default.error("error while creating new wallet connect session", error);
            this.emit(ADAPTER_EVENTS.ERRORED, error);
            return reject(error);
          });
        });
      }
      async onConnectHandler(params) {
        if (!this.connector || !this.wcProvider)
          throw WalletInitializationError.notReady("Wallet adapter is not ready yet");
        if (!this.chainConfig)
          throw WalletInitializationError.invalidParams("Chain config is not set");
        const {
          chainId
        } = params;
        import_loglevel.default.debug("connected chainId", chainId);
        const connectedChainId = parseInt(chainId, isHexStrict(chainId) ? 16 : 10);
        if (connectedChainId !== parseInt(this.chainConfig.chainId, 16)) {
          await this.createNewSession({
            forceNewSession: true
          });
          this.emit(ADAPTER_EVENTS.ERRORED, WalletInitializationError.fromCode(5e3, "Not connected to correct chainId. Expected: ".concat(this.chainConfig.chainId, ", Current: ").concat(connectedChainId, ", Please switch to correct chain from wallet")));
          return;
        }
        await this.wcProvider.setupProvider(this.connector);
        this.subscribeEvents(this.connector);
        this.status = ADAPTER_STATUS.CONNECTED;
        this.emit(ADAPTER_EVENTS.CONNECTED, {
          adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1,
          reconnected: this.rehydrated
        });
      }
      subscribeEvents(connector) {
        connector.on("session_update", async (error) => {
          if (error) {
            this.emit(ADAPTER_EVENTS.ERRORED, error);
          }
        });
      }
      getWalletConnectInstance() {
        const walletConnectOptions = this.adapterOptions.adapterSettings || {};
        walletConnectOptions.bridge = walletConnectOptions.bridge || "https://bridge.walletconnect.org";
        return new esm_default(walletConnectOptions);
      }
    };
  }
});
init_walletConnectV1Adapter_esm();
export {
  WalletConnectV1Adapter
};
//# sourceMappingURL=walletConnectV1Adapter.esm-ILODC6AI.js.map
